---
name: design
command: design
user_invocable: true
description: 架构设计。在方案探索（/explore）确定技术方案后、写计划（/plan）之前使用。输出模块划分、接口契约、数据模型，为实施计划提供蓝图。
---

# 架构设计 (Design)

> **角色**：架构师，将技术方案转化为可落地的系统蓝图
> **目标**：定义清晰的模块边界、接口契约、数据模型
> **原则**：单一职责、接口先行、数据驱动
> **流程**：`/explore` 之后 → `/plan` 之前
> **思考模式**：启用 ultrathink 深度思考，确保架构决策全面权衡

---

## 文档契约（铁律）

> **原则**：没有输入文档 → 不能执行；没有输出文档 → 不算完成

### 输入文档（门控检查）

| 文档 | 路径 | 必须 | 检查命令 |
|------|------|------|---------|
| **AC 文档** | `docs/需求文档/clarify_[功能名].md` | ✅ 必须 | `ls docs/需求文档/clarify_*.md` |
| **调研文档** | `docs/设计文档/调研_[功能名].md` | ⚠️ 推荐 | `ls docs/设计文档/调研_*.md` |

**门控规则**：
```bash
# 门控检查：AC 文档必须存在
CLARIFY_DOC=$(ls docs/需求文档/clarify_*.md 2>/dev/null | head -1)
if [ -z "$CLARIFY_DOC" ]; then
  echo "❌ 门控失败: AC 文档不存在"
  echo "   修复: 先执行 /clarify 生成需求文档"
  exit 1
fi
echo "✅ AC 文档: $CLARIFY_DOC"

# 检查调研文档（推荐但非强制）
EXPLORE_DOC=$(ls docs/设计文档/调研_*.md 2>/dev/null | head -1)
if [ -z "$EXPLORE_DOC" ]; then
  echo "⚠️ 调研文档不存在，建议先执行 /explore"
else
  echo "✅ 调研文档: $EXPLORE_DOC"
fi
```

**门控失败处理**：
- AC 文档不存在 → **停止执行**，先执行 `/clarify`
- 调研文档不存在 → 警告，建议先执行 `/explore`

### 输出文档（强制）

| 文档 | 路径 | 用途 |
|------|------|------|
| **设计文档** | `docs/设计文档/设计_[功能名].md` | /plan 依赖 |

**输出规则**：
- 未输出设计文档 → **不算完成**
- 完成提示必须包含输出文档的完整路径
- 设计文档必须包含：模块划分 + 接口设计 + 数据模型

**下游依赖**：
- `/plan` 依赖此文档

---

## 依赖规范

本 Skill 依赖以下规范文件：

| 规范文件 | 覆盖内容 |
|---------|---------|
| `.claude/rules/代码质量.md` | 项目铁律、代码规范 |
| `.claude/rules/全栈开发.md` | API 设计、前后端协作 |
| `.claude/rules/性能效率.md` | 数据库设计、缓存策略 |
| `.claude/rules/文档规范.md` | 设计文档存放位置 |

> **职责分离**：本 Skill 定义架构设计**流程**，`rules/` 定义**设计标准**。

---

## 核心原则

| 原则 | 说明 |
|------|------|
| **单一职责** | 每个模块只做一件事 |
| **接口先行** | 先定义接口，再考虑实现 |
| **数据驱动** | 从数据模型出发设计系统 |
| **最小依赖** | 模块间依赖越少越好 |
| **可测试性** | 设计时就考虑如何测试 |

---

## 触发方式

用户输入 `/design` 时激活此 skill。

**适用场景**：
- `/explore` 已确定技术方案
- 需要多模块协作的功能
- 涉及 API 设计或数据库设计
- 前后端需要明确接口契约

**不适用场景**：
- 简单的单文件修改
- Bug 修复
- 纯 UI 调整

---

## 前置条件

必须有以下输入：

1. **AC 来源文档**（必须）：`docs/需求文档/clarify_[功能名].md`
2. `/explore` 的输出（推荐方案）或用户明确的技术方案说明

**检查 AC 文档**：

```bash
# 检查 AC 文档是否存在
ls docs/需求文档/clarify_*.md 2>/dev/null
```

如果 AC 文档不存在，建议先执行 `/clarify`。
如果技术方案不清晰，建议先执行 `/explore`。

> ⚠️ **AC 一致性**：架构设计必须满足 /clarify 的所有 AC，不能遗漏

---

## 执行流程

### Phase 1: 确认技术方案和 AC

```markdown
## 技术方案和 AC 确认

**AC 来源文档**：`docs/需求文档/clarify_[功能名].md`

**方案来源**：[/explore 输出 或 用户说明]

**核心技术选型**：
- 语言/框架：[如 Python/FastAPI]
- 数据库：[如 MySQL + Qdrant]
- 前端：[如 React/TypeScript]

**需要满足的 AC（摘要）**：
- AC-1: [简述] → 影响模块：[xxx]
- AC-2: [简述] → 影响模块：[xxx]
- ...

**关键约束**：
- [性能要求]
- [安全要求]
- [兼容性要求]

以上确认无误？架构设计将确保满足所有 AC。
```

> ⚠️ **AC 覆盖检查**：设计完成后需验证每个 AC 都有对应的模块/接口支撑

---

### Phase 2: 模块划分

**原则**：按业务能力划分，而非技术层次

```markdown
## 模块划分

### 系统边界图

```
┌─────────────────────────────────────────────────┐
│                    系统名称                       │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐      │
│  │ 模块 A   │  │ 模块 B   │  │ 模块 C   │      │
│  │          │──│          │──│          │      │
│  └──────────┘  └──────────┘  └──────────┘      │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 模块职责

| 模块 | 职责 | 对外接口 | 依赖 |
|------|------|---------|------|
| 模块 A | [一句话描述] | [暴露的能力] | [依赖的模块] |
| 模块 B | [一句话描述] | [暴露的能力] | [依赖的模块] |
| 模块 C | [一句话描述] | [暴露的能力] | [依赖的模块] |

### 模块边界检查

- [ ] 每个模块职责单一？
- [ ] 模块间无循环依赖？
- [ ] 依赖方向正确（高层不依赖低层）？
```

---

### Phase 3: 接口设计

**原则**：接口是契约，变更成本高，要慎重设计

#### 3.1 后端 API 设计

```markdown
## API 接口设计

### API 1: [接口名称]

| 属性 | 值 |
|------|---|
| **路径** | `POST /api/v1/xxx` |
| **描述** | [一句话描述功能] |
| **认证** | 需要 / 不需要 |

**请求参数**：

```json
{
  "field1": "string, 必填, 描述",
  "field2": 123,  // number, 可选, 描述
  "field3": {
    "nested": "嵌套对象"
  }
}
```

**成功响应** (200)：

```json
{
  "code": 0,
  "message": "success",
  "data": {
    "id": 123,
    "created_at": "2025-01-23T10:00:00Z"
  }
}
```

**错误响应**：

| 状态码 | code | message | 场景 |
|-------|------|---------|------|
| 400 | 40001 | 参数错误 | field1 为空 |
| 404 | 40401 | 资源不存在 | 找不到记录 |
| 500 | 50001 | 服务异常 | 内部错误 |
```

#### 3.2 模块间接口设计

```markdown
### 内部接口: [服务名]

**调用方**：模块 A
**提供方**：模块 B

```python
# 接口定义
class XxxService:
    async def method_name(
        self,
        param1: str,
        param2: int | None = None
    ) -> ResultType:
        """
        功能描述

        Args:
            param1: 参数说明
            param2: 参数说明

        Returns:
            返回值说明

        Raises:
            XxxError: 异常场景
        """
        ...
```
```

---

### Phase 4: 数据模型设计

**原则**：数据结构决定程序结构

#### 4.1 数据库表设计

```markdown
## 数据模型

### 表: table_name

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 主键 |
| name | VARCHAR(100) | NOT NULL | 名称 |
| status | TINYINT | NOT NULL, DEFAULT 0 | 状态: 0-待处理, 1-处理中, 2-完成 |
| created_at | DATETIME | NOT NULL, DEFAULT NOW() | 创建时间 |
| updated_at | DATETIME | ON UPDATE NOW() | 更新时间 |

**索引**：
- `idx_status`: (status) - 按状态查询
- `idx_created_at`: (created_at) - 按时间排序

**关联关系**：
- table_name.user_id → users.id (多对一)
```

#### 4.2 ER 图

```markdown
### 实体关系图

```
┌──────────────┐       ┌──────────────┐
│    User      │       │   Document   │
├──────────────┤       ├──────────────┤
│ id           │───┐   │ id           │
│ name         │   │   │ title        │
│ email        │   └──→│ user_id (FK) │
└──────────────┘       │ status       │
                       └──────────────┘
```
```

#### 4.3 数据流图

```markdown
### 数据流

```
用户请求
    ↓
API 层（参数校验）
    ↓
Service 层（业务逻辑）
    ↓
Repository 层（数据访问）
    ↓
数据库
```
```

---

### Phase 5: 设计验证

```markdown
## 设计检查清单

### 模块设计
- [ ] 职责单一，边界清晰
- [ ] 无循环依赖
- [ ] 依赖方向正确

### 接口设计
- [ ] RESTful 风格（如适用）
- [ ] 错误码规范统一
- [ ] 参数校验完整
- [ ] 响应格式一致

### 数据模型
- [ ] 字段类型合适
- [ ] 索引设计合理
- [ ] 关联关系正确
- [ ] 考虑了扩展性

### 非功能需求
- [ ] 性能：热点查询有索引
- [ ] 安全：敏感数据加密
- [ ] 可观测：关键路径有日志
```

---

## 输出模板

设计完成后，输出架构设计文档到指定路径：

**📁 文档保存路径**：`docs/设计文档/设计_[功能名].md`

```markdown
# [功能名称] 架构设计

**设计日期**：YYYY-MM-DD
**状态**：已确认
**文档路径**：docs/设计文档/设计_[功能名].md
**前置文档**：
- AC 文档：docs/需求文档/clarify_[功能名].md
- 调研文档：docs/设计文档/调研_[功能名].md（如有）

---

## 1. 技术方案

[来自 /explore 的选型结论]

## 2. 模块划分

[模块边界图 + 职责表]

## 3. 接口设计

### 3.1 API 接口
[所有对外 API]

### 3.2 内部接口
[模块间接口]

## 4. 数据模型

### 4.1 表结构
[数据库表设计]

### 4.2 实体关系
[ER 图]

## 5. 设计约束

- [性能约束]
- [安全约束]
- [兼容性约束]

---

设计已完成，自动进入评审环节...

---

**⚠️ 自动执行 `/critique` 评审架构设计**
```

---

## 设计深度指南

根据功能复杂度，选择合适的设计深度：

| 复杂度 | 模块划分 | 接口设计 | 数据模型 |
|--------|---------|---------|---------|
| **简单**（1-2 个 API） | 简略 | 完整 | 完整 |
| **中等**（3-5 个 API） | 完整 | 完整 | 完整 |
| **复杂**（>5 个 API） | 详细 + 图 | 完整 + 示例 | 完整 + ER图 |

---

## 与其他 Skills 的关系

```
/clarify（需求澄清）
    ↓ 需求清晰后
/explore（方案探索）
    ↓ 方案确定后
/design（架构设计）← 当前
    ↓ 设计完成后
/critique（评审架构）← 自动触发
    ↓ 评审通过后
/plan（写计划）
    ↓ 计划完成后
/critique（评审计划）← 自动触发
    ↓ 评审通过后
/run-plan（执行计划）
    ↓
/check（开发检查）
```

---

## ⛔ 边界约束（铁律）

> **`/design` 的职责边界：只做架构设计，不能跳过后续环节**

| 禁止行为 | 说明 |
|---------|------|
| ❌ 跳过 `/critique` 直接进入 `/plan` | 评审是质量门控，建议执行 |
| ❌ 跳过 `/plan` 直接进入 `/run-plan` | 必须有实施计划 |
| ❌ 跳过整个流程直接修改代码 | 必须走完 plan → test-gen → run-plan |
| ❌ 在设计阶段写任何实现代码 | 只输出设计文档，不输出代码 |

**正确的完成动作**：
1. 输出设计文档到 `docs/设计文档/设计_[功能名].md`
2. 展示完成提示
3. 进入下一环节 `/critique` 或 `/plan`（正常流转）或等待用户指令

**跳过环节的处理**：
- `/critique` 可以跳过（非强制），但建议执行
- `/plan` 不能跳过，必须有实施计划才能执行

---

## 禁止行为

| 禁止 | 原因 |
|------|------|
| 跳过接口设计直接写代码 | 接口是契约，事后改成本高 |
| 用技术层次划分模块 | 应按业务能力划分 |
| 设计过度详细 | 2-5 个 API 不需要复杂架构图 |
| 忽略错误处理设计 | 错误码和错误消息要提前定义 |

---

## 完成检查清单

- [ ] 技术方案已确认
- [ ] 模块划分清晰，无循环依赖
- [ ] API 接口定义完整（路径、参数、响应、错误码）
- [ ] 数据模型设计完整（表结构、索引、关联）
- [ ] **设计文档已输出到 `docs/设计文档/设计_[功能名].md`**
- [ ] 自动执行 `/critique` 评审
- [ ] 评审通过后进入 `/plan` 阶段

---

## ✅ 完成提示

```
✅ 架构设计完成

📁 输出文档：docs/设计文档/设计_[功能名].md
📋 设计内容：
   - 模块划分：X 个模块
   - API 接口：X 个
   - 数据表：X 个

📎 前置文档：
   - AC 文档：docs/需求文档/clarify_[功能名].md
   - 调研文档：docs/设计文档/调研_[功能名].md

🎯 下一步：
   1. 自动执行 /critique 评审设计
   2. 评审通过后执行 /plan（写计划）
```
