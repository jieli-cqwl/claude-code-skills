---
name: design
command: design
user_invocable: true
parallel_mode: true
description: 架构设计。在方案探索（/explore）确定技术方案后、写计划（/plan）之前使用。输出模块划分、接口契约、数据模型，为实施计划提供蓝图。
---

# 架构设计 (Design)

> **角色**：架构师，将技术方案转化为可落地的系统蓝图
> **目标**：定义清晰的模块边界、接口契约、数据模型
> **原则**：单一职责、接口先行、数据驱动
> **流程**：`/explore` 之后 → `/plan` 之前
> **思考模式**：启用 ultrathink 深度思考，确保架构决策全面权衡

---

## 按需执行指南（P2 增强）

> **原则**：不是所有需求都需要完整架构设计，根据规模智能判断

### 何时需要 /design

| 需求规模 | AC 数量 | 是否需要 /design | 说明 |
|---------|--------|-----------------|------|
| **小** | ≤ 3 | ❌ 跳过 | 直接 /plan，无需设计 |
| **中** | 4-8 | ⚠️ 简化版 | 只做接口设计，跳过架构分析 |
| **大** | > 8 | ✅ 完整版 | 完整架构设计 |

### 自动判断逻辑

```bash
# 从 AC 文档分析需要哪种 /design 模式
analyze_design_mode() {
    local clarify_doc="$1"

    # 统计 AC 数量
    AC_COUNT=$(grep -c "^| AC-" "$clarify_doc" 2>/dev/null || echo "0")

    # 统计涉及模块数
    MODULE_COUNT=$(grep -E "后端|前端|数据库|API|服务" "$clarify_doc" | wc -l)

    # 判断设计模式
    if [ "$AC_COUNT" -le 3 ] && [ "$MODULE_COUNT" -le 2 ]; then
        echo "skip"
        echo "💡 建议：小需求（AC ≤ 3），可跳过 /design，直接执行 /plan"
    elif [ "$AC_COUNT" -le 8 ]; then
        echo "simplified"
        echo "📋 中需求（AC 4-8），执行简化版 /design（只做接口设计）"
    else
        echo "full"
        echo "📐 大需求（AC > 8），执行完整版 /design"
    fi
}
```

### 设计模式对比

| 模式 | 输出内容 | 适用场景 |
|------|---------|---------|
| **跳过** | 无 | 小需求，直接写 plan |
| **简化版** | 接口设计 + 数据模型 | 中需求，快速设计 |
| **完整版** | 模块划分 + 接口设计 + 数据模型 + 架构图 | 大需求，完整设计 |

### 简化版 /design 模板

```markdown
# [功能名称] 简化设计

## 接口设计

| 接口 | 方法 | 路径 | 说明 |
|------|------|------|------|
| 创建 | POST | /api/xxx | ... |
| 查询 | GET | /api/xxx | ... |

## 数据模型

| 字段 | 类型 | 说明 |
|------|------|------|
| id | int | 主键 |
| ... | ... | ... |

## 下一步

直接执行 /plan
```

---

## 文档契约（铁律）

> **原则**：没有输入文档 → 不能执行；没有输出文档 → 不算完成

### 输入文档（门控检查）

| 文档 | 路径 | 必须 | 检查命令 |
|------|------|------|---------|
| **AC 文档** | `docs/需求澄清/clarify_[功能名].md` | ✅ 必须 | `ls docs/需求澄清/clarify_*.md` |
| **调研文档** | `docs/设计文档/调研_[功能名].md` | ⚠️ 推荐 | `ls docs/设计文档/调研_*.md` |

**门控规则**：
```bash
# 门控检查：AC 文档必须存在
CLARIFY_DOC=$(ls docs/需求澄清/clarify_*.md 2>/dev/null | head -1)
if [ -z "$CLARIFY_DOC" ]; then
  echo "❌ 门控失败: AC 文档不存在"
  echo "   修复: 先执行 /clarify 生成需求文档"
  exit 1
fi
echo "✅ AC 文档: $CLARIFY_DOC"

# 检查调研文档（推荐但非强制）
EXPLORE_DOC=$(ls docs/设计文档/调研_*.md 2>/dev/null | head -1)
if [ -z "$EXPLORE_DOC" ]; then
  echo "⚠️ 调研文档不存在，建议先执行 /explore"
else
  echo "✅ 调研文档: $EXPLORE_DOC"
fi
```

**门控失败处理**：
- AC 文档不存在 → **停止执行**，先执行 `/clarify`
- 调研文档不存在 → 警告，建议先执行 `/explore`

### 输出文档（强制）

| 文档 | 路径 | 用途 |
|------|------|------|
| **设计文档** | `docs/设计文档/设计_[功能名].md` | /plan 依赖 |

**输出规则**：
- 未输出设计文档 → **不算完成**
- 完成提示必须包含输出文档的完整路径
- 设计文档必须包含：模块划分 + 接口设计 + 数据模型

**下游依赖**：
- `/plan` 依赖此文档

---

## 依赖规范

本 Skill 依赖以下规范文件：

| 规范文件 | 覆盖内容 |
|---------|---------|
| `.claude/rules/代码质量.md` | 项目铁律、代码规范 |
| `.claude/rules/全栈开发.md` | API 设计、前后端协作 |
| `.claude/rules/性能效率.md` | 数据库设计、缓存策略 |
| `.claude/rules/文档规范.md` | 设计文档存放位置 |

> **职责分离**：本 Skill 定义架构设计**流程**，`rules/` 定义**设计标准**。

---

## 设计哲学：简单、合适、演化

> 架构设计的核心是"恰到好处"，而非"越复杂越好"或"越简单越好"

### 三大原则

| 原则 | 含义 | 应用 |
|------|------|------|
| **简单** | 不过度设计，避免"万一将来需要"的预设 | 只有多个实现时才抽象接口；不为未来需求预设功能 |
| **合适** | 该复杂时复杂（业务本身复杂），该简单时简单 | 复杂度应匹配业务复杂度，不多不少 |
| **演化** | 根据实际需求演化，重复 3 次再抽象 | 为演化留空间（接口、配置、扩展字段），但不提前实现 |

### 与技术原则的关系

以下技术原则在应用时，都应遵循"简单、合适、演化"的哲学：

- **单一职责** + 简单原则 → 不要为了"单一职责"过度拆分模块
- **接口先行** + 合适原则 → 只有多个实现时才抽象接口
- **数据驱动** + 演化原则 → 数据模型预留扩展字段（如 JSON 字段）
- **最小依赖** + 演化原则 → 依赖关系根据实际需求演化，不预设
- **可测试性** + 简单原则 → 不为了测试而过度抽象

---

## 技术原则

| 原则 | 说明 |
|------|------|
| **单一职责** | 每个模块只做一件事 |
| **接口先行** | 先定义接口，再考虑实现 |
| **数据驱动** | 从数据模型出发设计系统 |
| **最小依赖** | 模块间依赖越少越好 |
| **可测试性** | 设计时就考虑如何测试 |

---

## 触发条件

当用户使用以下任一方式时，立即激活此 skill：
- 说"**设计架构**"或"**架构设计**"（主触发词）
- 使用命令：`/design`
- 说"画个架构图"、"设计一下"
- 说"怎么拆分模块"
- 说"接口怎么设计"
- 说"数据模型怎么设计"

**适用场景**：
- `/explore` 已确定技术方案
- 需要多模块协作的功能
- 涉及 API 设计或数据库设计
- 前后端需要明确接口契约

**不适用场景**：
- 简单的单文件修改
- Bug 修复
- 纯 UI 调整

---

## 前置条件

必须有以下输入：

1. **AC 来源文档**（必须）：`docs/需求澄清/clarify_[功能名].md`
2. `/explore` 的输出（推荐方案）或用户明确的技术方案说明

**检查 AC 文档**：

```bash
# 检查 AC 文档是否存在
ls docs/需求澄清/clarify_*.md 2>/dev/null
```

如果 AC 文档不存在，建议先执行 `/clarify`。
如果技术方案不清晰，建议先执行 `/explore`。

> ⚠️ **AC 一致性**：架构设计必须满足 /clarify 的所有 AC，不能遗漏

---

## 执行流程

### Phase 1: 确认技术方案和 AC

```markdown
## 技术方案和 AC 确认

**AC 来源文档**：`docs/需求澄清/clarify_[功能名].md`

**方案来源**：[/explore 输出 或 用户说明]

**核心技术选型**：
- 语言/框架：[如 Python/FastAPI]
- 数据库：[如 MySQL + Qdrant]
- 前端：[如 React/TypeScript]

**需要满足的 AC（摘要）**：
- AC-1: [简述] → 影响模块：[xxx]
- AC-2: [简述] → 影响模块：[xxx]
- ...

**关键约束**：
- [性能要求]
- [安全要求]
- [兼容性要求]

以上确认无误？架构设计将确保满足所有 AC。
```

> ⚠️ **AC 覆盖检查**：设计完成后需验证每个 AC 都有对应的模块/接口支撑

---

### Phase 2: 模块划分

**原则**：按业务能力划分，而非技术层次

```markdown
## 模块划分

### 系统边界图

```
┌─────────────────────────────────────────────────┐
│                    系统名称                       │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐      │
│  │ 模块 A   │  │ 模块 B   │  │ 模块 C   │      │
│  │          │──│          │──│          │      │
│  └──────────┘  └──────────┘  └──────────┘      │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 模块职责

| 模块 | 职责 | 对外接口 | 依赖 |
|------|------|---------|------|
| 模块 A | [一句话描述] | [暴露的能力] | [依赖的模块] |
| 模块 B | [一句话描述] | [暴露的能力] | [依赖的模块] |
| 模块 C | [一句话描述] | [暴露的能力] | [依赖的模块] |

### 模块边界检查

- [ ] 每个模块职责单一？
- [ ] 模块间无循环依赖？
- [ ] 依赖方向正确（高层不依赖低层）？
```

---

### Phase 3: 接口设计

**原则**：接口是契约，变更成本高，要慎重设计

#### 3.1 后端 API 设计

```markdown
## API 接口设计

### API 1: [接口名称]

| 属性 | 值 |
|------|---|
| **路径** | `POST /api/v1/xxx` |
| **描述** | [一句话描述功能] |
| **认证** | 需要 / 不需要 |

**请求参数**：

```json
{
  "field1": "string, 必填, 描述",
  "field2": 123,  // number, 可选, 描述
  "field3": {
    "nested": "嵌套对象"
  }
}
```

**成功响应** (200)：

```json
{
  "code": 0,
  "message": "success",
  "data": {
    "id": 123,
    "created_at": "2025-01-23T10:00:00Z"
  }
}
```

**错误响应**：

| 状态码 | code | message | 场景 |
|-------|------|---------|------|
| 400 | 40001 | 参数错误 | field1 为空 |
| 404 | 40401 | 资源不存在 | 找不到记录 |
| 500 | 50001 | 服务异常 | 内部错误 |
```

#### 3.2 模块间接口设计

```markdown
### 内部接口: [服务名]

**调用方**：模块 A
**提供方**：模块 B

```python
# 接口定义
class XxxService:
    async def method_name(
        self,
        param1: str,
        param2: int | None = None
    ) -> ResultType:
        """
        功能描述

        Args:
            param1: 参数说明
            param2: 参数说明

        Returns:
            返回值说明

        Raises:
            XxxError: 异常场景
        """
        ...
```
```

---

### Phase 4: 数据模型设计

**原则**：数据结构决定程序结构

#### 4.1 数据库表设计

```markdown
## 数据模型

### 表: table_name

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 主键 |
| name | VARCHAR(100) | NOT NULL | 名称 |
| status | TINYINT | NOT NULL, DEFAULT 0 | 状态: 0-待处理, 1-处理中, 2-完成 |
| created_at | DATETIME | NOT NULL, DEFAULT NOW() | 创建时间 |
| updated_at | DATETIME | ON UPDATE NOW() | 更新时间 |

**索引**：
- `idx_status`: (status) - 按状态查询
- `idx_created_at`: (created_at) - 按时间排序

**关联关系**：
- table_name.user_id → users.id (多对一)
```

#### 4.2 ER 图

```markdown
### 实体关系图

```
┌──────────────┐       ┌──────────────┐
│    User      │       │   Document   │
├──────────────┤       ├──────────────┤
│ id           │───┐   │ id           │
│ name         │   │   │ title        │
│ email        │   └──→│ user_id (FK) │
└──────────────┘       │ status       │
                       └──────────────┘
```
```

#### 4.3 数据流图

```markdown
### 数据流

```
用户请求
    ↓
API 层（参数校验）
    ↓
Service 层（业务逻辑）
    ↓
Repository 层（数据访问）
    ↓
数据库
```
```

---

### Phase 5: 设计验证

```markdown
## 设计检查清单

### 模块设计
- [ ] 职责单一，边界清晰
- [ ] 无循环依赖
- [ ] 依赖方向正确

### 接口设计
- [ ] RESTful 风格（如适用）
- [ ] 错误码规范统一
- [ ] 参数校验完整
- [ ] 响应格式一致

### 数据模型
- [ ] 字段类型合适
- [ ] 索引设计合理
- [ ] 关联关系正确
- [ ] 考虑了扩展性

### 非功能需求
- [ ] 性能：热点查询有索引
- [ ] 安全：敏感数据加密
- [ ] 可观测：关键路径有日志
```

---

## 并行架构

> **优化策略**：通过分层并行设计，解决 Agent 间的隐式依赖，确保设计一致性。
> **核心原则**：有依赖的任务串行，无依赖的任务并行。

### Parallel Phase 1a: 数据模型设计（串行，1 Agent）

**为什么串行**：数据模型是其他设计的基础，API 设计和业务逻辑都依赖数据模型。

| Agent | 任务 | 输出 |
|-------|------|------|
| Agent 1 | **数据模型设计** | 实体定义、字段类型、关联关系、ER 图 |

**⚠️ Phase 1a 专属超时和恢复机制**：

> **配置来源**：`docs/需求澄清/clarify_skills并行优化.md` 第 7.3 节超时配置表

- **超时时间**：90 秒（见 AC 文档，高于普通 Agent 的 60 秒，因为数据模型设计更复杂）
- **超时处理**：
  1. 如果 90 秒内未完成，立即通知用户
  2. 提供选项：
     - ① 继续等待（最多再等 90 秒）
     - ② 用户提供简化数据模型（推荐，如已有 ER 图或表结构）
     - ③ 停止执行，报告失败
- **失败恢复**：
  1. 如果 Agent 1 失败，询问用户是否提供已有的数据模型（如 ER 图、表结构）
  2. 如果用户无法提供，停止执行并报告失败，等待用户决策

**Agent 1 返回后，将数据模型传递给 Phase 1b 的所有 Agent。**

---

### Parallel Phase 1b: 并行设计（6 Agent，subagent_type=general-purpose）

基于 Phase 1a 的数据模型，同时启动 6 个设计任务：

| Agent | 任务 | 输入依赖 | 输出 |
|-------|------|---------|------|
| Agent 2 | **数据访问层设计** | 数据模型（Phase 1a） | Repository 接口、DAO 模式、查询方法 |
| Agent 3 | **业务逻辑设计** | 数据模型（Phase 1a） | Service 接口、业务流程、状态机、验证规则 |
| Agent 4 | **API 接口设计** | 数据模型（Phase 1a） | REST 端点、请求/响应格式、DTO 定义 |
| Agent 5 | **错误处理设计** | 数据模型（Phase 1a） | 异常类型、错误码、响应格式 |
| Agent 6 | **安全机制设计** | 数据模型（Phase 1a） | 认证方式、授权策略、数据保护 |
| Agent 7 | **数据迁移设计** | 数据模型（Phase 1a） | Schema 变更脚本、迁移策略、回滚方案 |

**注意**：原业务层 3 个 Agent（核心逻辑、业务规则、状态管理）合并为 1 个 Agent 3（业务逻辑设计），因为这三者高度相关，拆分会导致重复和不一致。

**每个 Agent 返回结构化 JSON**：

```json
{
  "layer": "数据层|业务层|接口层",
  "agent_id": 2-7,
  "task": "任务名称",
  "input_dependency": "依赖的 Phase 1a 输出（如有）",
  "design": {
    "summary": "设计概述",
    "details": { ... },
    "interfaces": ["对外暴露的接口"],
    "dependencies": ["依赖的其他模块"],
    "constraints": ["约束条件"]
  },
  "status": "completed|failed",
  "error": null
}
```

**等待所有 6 个 Agent 完成后继续。**

---

### Parallel Phase 2: 一致性校验（串行）

> **用户进度提示**：在执行每个 Phase 前输出进度信息

```markdown
📊 /design 执行进度

⏳ Phase 1a: 数据模型设计... ✅ 完成
⏳ Phase 1b: 并行设计（数据层 + 业务层 + 接口层）... ✅ 完成（5/6 任务成功）
⏳ Phase 2: 一致性校验... ⏳ 执行中
⏳ Phase 3: 整合输出设计文档
```

> **关键环节**：确保各层设计间的接口匹配和契约一致

主 Agent 检查各层设计间的一致性：

#### 校验项目

| 校验类型 | 检查内容 | 冲突示例 |
|---------|---------|---------|
| **数据模型 ↔ 数据访问层** | Repository 方法与实体字段匹配 | Repository 查询了不存在的字段 |
| **数据模型 ↔ API 接口** | DTO 字段与实体字段对应 | 数据库用 snake_case，API 用 camelCase 未转换 |
| **数据访问层 ↔ 业务逻辑** | Repository 接口与 Service 调用匹配 | Service 调用了不存在的 Repository 方法 |
| **业务逻辑 ↔ API 接口** | Service 返回类型与 API 响应格式一致 | Service 返回 Entity，API 需要 DTO |
| **错误处理 ↔ 业务逻辑** | 异常类型与错误码映射完整 | 业务抛出的异常没有对应错误码 |
| **安全机制 ↔ API 接口** | 认证/授权要求与接口标注一致 | 接口标注无需认证但业务层检查权限 |

#### 一致性校验流程

```markdown
## 一致性校验报告

### 校验结果

| 校验项 | 状态 | 说明 |
|-------|------|------|
| 数据层 ↔ 业务层 | ✅ 通过 | - |
| 业务层 ↔ 接口层 | ⚠️ 发现冲突 | 见下方详情 |
| ... | ... | ... |

### 冲突详情（如有）

#### 冲突 1: [冲突描述]
- **位置**：Agent 4（业务逻辑）↔ Agent 7（API 接口）
- **问题**：[具体问题]
- **建议解决方案**：[解决方案]

### 校验结论

- [ ] 所有校验通过 → 继续 Phase 3
- [ ] 存在冲突 → 列出冲突并给出解决建议，等待确认后继续
```

---

### Parallel Phase 3: 整合输出设计文档（串行）

主 Agent 整合所有 Agent 的设计输出，生成完整的架构设计文档：

1. **汇总各层设计**：合并 7 个 Agent 的输出（Phase 1a: 1 + Phase 1b: 6）
2. **应用一致性修正**：根据 Phase 2 的校验结果调整
3. **生成统一文档**：按标准模板输出到 `docs/设计文档/设计_[功能名].md`

---

### 并行设计错误处理

#### Agent 失败处理

| 场景 | 处理方式 |
|------|---------|
| Phase 1a Agent 失败 | **阻塞**：数据模型是基础，必须成功才能继续 |
| Phase 1b 单个 Agent 超时 | 标记该 Agent 为失败，继续等待其他 Agent |
| Phase 1b 单个 Agent 返回错误 | 记录错误信息，在汇总时标注缺失部分 |
| Phase 1b 多个 Agent 失败（≥3） | 停止执行，报告失败原因，等待用户决策 |
| Phase 1b 全部 Agent 失败 | 报告错误，请求用户介入 |

#### 失败通知机制

```markdown
⚠️ 并行设计失败通知

Phase 1a 状态: ✅ 数据模型设计完成
Phase 1b 状态: 检测到 X 个 Agent 失败（≥3），已停止执行。

**失败的 Agent**：
- Agent N: [失败原因]
- ...

**请选择处理方式**：
1. 重试失败的 Agent（推荐）
2. 基于已完成的 Agent 输出继续（部分设计）
3. 终止本次设计
```

#### 错误报告格式

```json
{
  "parallel_execution": {
    "phase_1a": {"status": "completed", "agent": 1},
    "phase_1b": {
      "total_agents": 6,
      "completed": 5,
      "failed": 1,
      "failed_agents": [
        {"agent_id": 7, "task": "数据迁移设计", "error": "超时"}
      ]
    }
  },
  "fallback_mode": "无（失败数 < 3）",
  "missing_sections": ["数据迁移"]
}
```

---

## 输出模板

设计完成后，输出架构设计文档到指定路径：

**📁 文档保存路径**：`docs/设计文档/设计_[功能名].md`

```markdown
# [功能名称] 架构设计

**设计日期**：YYYY-MM-DD
**状态**：已确认
**文档路径**：docs/设计文档/设计_[功能名].md
**前置文档**：
- AC 文档：docs/需求澄清/clarify_[功能名].md
- 调研文档：docs/设计文档/调研_[功能名].md（如有）

---

## 1. 技术方案

[来自 /explore 的选型结论]

## 2. 模块划分

[模块边界图 + 职责表]

## 3. 接口设计

### 3.1 API 接口
[所有对外 API]

### 3.2 内部接口
[模块间接口]

## 4. 数据模型

### 4.1 表结构
[数据库表设计]

### 4.2 实体关系
[ER 图]

## 5. 设计约束

- [性能约束]
- [安全约束]
- [兼容性约束]

---

设计已完成，自动进入评审环节...

---

**⚠️ 自动执行 `/critique` 评审架构设计**
```

---

## 设计深度指南

根据功能复杂度，选择合适的设计深度：

| 复杂度 | 模块划分 | 接口设计 | 数据模型 |
|--------|---------|---------|---------|
| **简单**（1-2 个 API） | 简略 | 完整 | 完整 |
| **中等**（3-5 个 API） | 完整 | 完整 | 完整 |
| **复杂**（>5 个 API） | 详细 + 图 | 完整 + 示例 | 完整 + ER图 |

---

## 与其他 Skills 的关系

```
/clarify（需求澄清）
    ↓ 需求清晰后
/explore（方案探索）
    ↓ 方案确定后
/design（架构设计）← 当前
    ↓ 设计完成后
/critique（评审架构）← 自动触发
    ↓ 评审通过后
/plan（写计划）
    ↓ 计划完成后
/critique（评审计划）← 自动触发
    ↓ 评审通过后
/run-plan（执行计划）
    ↓
/check（开发检查）
```

---

## ⛔ 边界约束（铁律）

> **`/design` 的职责边界：只做架构设计，不能跳过后续环节**

| 禁止行为 | 说明 |
|---------|------|
| ❌ 跳过 `/critique` 直接进入 `/plan` | 评审是质量门控，建议执行 |
| ❌ 跳过 `/plan` 直接进入 `/run-plan` | 必须有实施计划 |
| ❌ 跳过整个流程直接修改代码 | 必须走完 plan → test-gen → run-plan |
| ❌ 在设计阶段写任何实现代码 | 只输出设计文档，不输出代码 |

**正确的完成动作**：
1. 输出设计文档到 `docs/设计文档/设计_[功能名].md`
2. 展示完成提示
3. 进入下一环节 `/critique` 或 `/plan`（正常流转）或等待用户指令

**跳过环节的处理**：
- `/critique` 可以跳过（非强制），但建议执行
- `/plan` 不能跳过，必须有实施计划才能执行

---

## 禁止行为

| 禁止 | 原因 |
|------|------|
| 跳过接口设计直接写代码 | 接口是契约，事后改成本高 |
| 用技术层次划分模块 | 应按业务能力划分 |
| 设计过度详细 | 2-5 个 API 不需要复杂架构图 |
| 忽略错误处理设计 | 错误码和错误消息要提前定义 |

---

## 完成检查清单

- [ ] 技术方案已确认
- [ ] 模块划分清晰，无循环依赖
- [ ] API 接口定义完整（路径、参数、响应、错误码）
- [ ] 数据模型设计完整（表结构、索引、关联）
- [ ] **设计文档已输出到 `docs/设计文档/设计_[功能名].md`**
- [ ] 自动执行 `/critique` 评审
- [ ] 评审通过后进入 `/plan` 阶段

---

## ✅ 完成提示

```
✅ 架构设计完成

📁 输出文档：docs/设计文档/设计_[功能名].md
📋 设计内容：
   - 模块划分：X 个模块
   - API 接口：X 个
   - 数据表：X 个

📎 前置文档：
   - AC 文档：docs/需求澄清/clarify_[功能名].md
   - 调研文档：docs/设计文档/调研_[功能名].md

🎯 下一步：
   1. 自动执行 /critique 评审设计
   2. 评审通过后执行 /plan（写计划）
```
