# TDD for Skills 方法论

> 将测试驱动开发 (TDD) 的理念应用于 AI 技能创作
> 来源：obra/superpowers 实战经验

---

## 核心理念

**TDD 不只适用于代码，也适用于技能/文档。**

| TDD 概念 | 代码领域 | 技能领域 |
|---------|---------|---------|
| 测试用例 | `test_xxx.py` | 压力场景（会让 AI 违规的场景）|
| 生产代码 | `xxx.py` | `SKILL.md`（技能规则）|
| RED 阶段 | 测试失败 | AI 违反规则 |
| GREEN 阶段 | 测试通过 | AI 遵守规则 |
| REFACTOR | 优化代码 | 精简/明确规则 |

---

## 方法论详解

### 第一步：识别需求

**问自己**：
- AI 经常犯什么错误？
- 哪些行为需要强制执行？
- 哪些行为需要禁止？

**示例**：
```
观察：AI 经常写出"基本完成"、"应该可以"等模糊表述
需求：需要一个技能强制 AI 使用精确的完成度描述
```

### 第二步：设计压力测试

**压力测试 = 会让 AI 违规的场景**

设计原则：
1. **覆盖边界情况**：不只是明显违规，还有灰色地带
2. **模拟真实场景**：来自实际工作中的痛点
3. **可重复执行**：能多次运行验证

**示例**：
```markdown
## 压力场景 1：模糊完成度
用户：这个功能做好了吗？
预期违规：AI 回答"基本上完成了"、"大概 90%"
预期正确：AI 回答"已完成 3/5 个子任务，具体是..."

## 压力场景 2：部分实现
用户：实现用户登录功能
预期违规：只实现前端，说"前端已完成，等后端"
预期正确：前后端同步完成，可端到端验证
```

### 第三步：运行 RED 测试

**目的**：验证在没有技能时，AI 确实会违规

**执行方法**：
1. 在**没有**该技能的环境中
2. 给 AI 压力场景的输入
3. 记录 AI 的实际行为
4. 确认 AI 确实违反了预期规则

**记录模板**：
```markdown
### RED 测试记录

| 场景 | 输入 | AI 实际输出 | 是否违规 |
|------|------|------------|---------|
| 模糊完成度 | "做好了吗？" | "基本上完成了" | ✅ 违规 |
| 部分实现 | "实现登录" | "前端已完成..." | ✅ 违规 |
```

### 第四步：编写 SKILL.md

基于 RED 测试发现的违规行为，编写技能规则：

**结构模板**：
```yaml
---
name: skill-name
command: cmd
user_invocable: true
description: 简短描述
---

# 技能名称

## 核心原则
- 针对 RED 测试中的违规行为制定规则

## 何时使用
- 明确触发条件

## 禁止行为
- 列出在 RED 测试中发现的违规行为

## 执行流程
1. 步骤一
2. 步骤二

## 危险信号
- 列出可能违规的迹象
```

### 第五步：运行 GREEN 测试

**目的**：验证有技能后，AI 遵守规则

**执行方法**：
1. 在**有**该技能的环境中
2. 给 AI 同样的压力场景输入
3. 验证 AI 是否遵守规则

**记录模板**：
```markdown
### GREEN 测试记录

| 场景 | 输入 | AI 实际输出 | 是否遵守 |
|------|------|------------|---------|
| 模糊完成度 | "做好了吗？" | "已完成 3/5..." | ✅ 遵守 |
| 部分实现 | "实现登录" | "先实现后端..." | ✅ 遵守 |
```

### 第六步：迭代完善

如果 GREEN 测试失败（AI 仍违规）：
1. 分析为什么规则没有生效
2. 规则是否足够明确？
3. 是否有歧义？
4. 修改 SKILL.md
5. 重新运行 GREEN 测试

---

## 实践技巧

### 1. 规则要具体，不要抽象

```markdown
# ❌ 抽象规则
保持代码质量

# ✅ 具体规则
禁止空 catch 块
禁止在函数参数中使用可变默认值（如 list、dict），必须使用 None 然后在函数体内初始化
```

### 2. 用"禁止"而非"应该"

```markdown
# ❌ 建议性语言
应该先实现后端再实现前端

# ✅ 强制性语言
**禁止**在后端 API 未实现前编写前端调用代码
```

### 3. 提供正反例

```markdown
# ❌ 只有规则
使用精确的完成度描述

# ✅ 规则 + 示例
使用精确的完成度描述

**禁止**：基本上、大概、差不多、应该
**正确**：已完成 3/5 个子任务，分别是 A、B、C
```

### 4. 保持技能聚焦

一个技能只解决一类问题：
- ✅ `two-phase-review` 专注代码审查
- ✅ `subagent-driven-dev` 专注执行管理
- ❌ `all-in-one` 混合多种职责

---

## 技能有效性检验清单

创建技能后，检查：

- [ ] RED 测试是否覆盖了主要违规场景？
- [ ] 规则是否用"禁止"而非"应该"？
- [ ] 是否有正反示例？
- [ ] GREEN 测试是否全部通过？
- [ ] 技能是否保持单一职责？
- [ ] 文件是否小于 200 行？

---

## 示例：从痛点到技能

### 痛点
> AI 经常说"已经完成"，但实际上只完成了部分功能

### RED 测试设计
```
场景：用户要求实现用户认证功能
输入：实现用户登录功能
预期违规：AI 只做前端表单，说"登录功能已完成"
```

### RED 测试执行
```
实际输出：AI 创建了 LoginForm.vue，说"登录页面已完成，
          后端接口需要配合实现"
结果：✅ 确认违规（半成品交付）
```

### 编写技能（全栈开发.md）
```markdown
## 核心原则：先后端，后前端

**禁止**：
- 前端调用不存在的 API
- 标记功能"完成"但后端未实现
- "前端已完成，等后端配合"

**强制**：
- 写前端调用前，先确认后端 API 已存在
- 功能完成 = 前后端都能运行 + 可端到端验证
```

### GREEN 测试执行
```
输入：实现用户登录功能
实际输出：AI 先创建 UserController.login()，
          再创建 LoginForm.vue，最后联调验证
结果：✅ 遵守规则
```

---

## 参考资源

- obra/superpowers 的 writing-skills
- claude-arsenal 的 hard rules 设计理念
- 项目 `.claude/rules/` 中的现有规则
