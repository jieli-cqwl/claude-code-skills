---
name: auto-dev
command: auto-dev
user_invocable: true
description: 自动循环开发（往死里干模式）。输入需求文档，自动执行完整开发链路（探索→设计→计划→多人协作实现→检查→验收），循环迭代直到可交付。内置严格 TDD、完成前验证、服务启动验证。效率提升 2-5 倍。
---

# 自动开发 (Auto Dev) - 往死里干模式

> **角色**：自主开发执行者（Tech Lead）
> **目标**：需求文档 → 可交付成品，全程无人值守
> **原理**：多人协作 + 严格 TDD + 完成前验证
> **场景**：白天写需求，晚上跑，早上交付
> **效率**：相比串行执行，提升 **2-5 倍**

---

## 参考规范（执行时自动加载）

| 规范 | 路径 | 用途 |
|------|------|------|
| **TDD 规范** | `~/.claude/reference/TDD规范.md` | 严格的测试驱动开发 |
| **完成前验证** | `~/.claude/reference/完成前验证.md` | 声明完成前的验证清单 |
| **并行拆分策略** | `~/.claude/reference/并行拆分策略.md` | 多人协作模式的拆分原则 |

---

## 核心铁律

| 铁律 | 说明 |
|------|------|
| **严格 TDD** | 没有先失败的测试，就没有生产代码 |
| **完成前验证** | 只有亲眼看到验证命令成功，才能声称完成 |
| **服务启动验证** | 必须亲眼看到服务正常启动并响应请求 |
| **文件边界** | 多人协作时，每个开发者只修改分配的文件 |

---

## 核心原理（多人协作模式）

```
┌─────────────────────────────────────────────────────────────┐
│              Auto Dev 工作流（往死里干模式）                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  需求文档（PRD/需求描述）                                     │
│        ↓                                                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  循环直到完成                                         │   │
│  │                                                      │   │
│  │  阶段 1: /explore → /design → /review → /plan       │   │
│  │        ↓                                            │   │
│  │  阶段 2: Tech Lead 前置工作（基础设施）               │   │
│  │        ↓                                            │   │
│  │  阶段 3: 开发者并行执行（Alice/Bob/Charlie）          │   │
│  │          ├── Alice: 功能 A（前+后端，严格 TDD）       │   │
│  │          ├── Bob: 功能 B（前+后端，严格 TDD）         │   │
│  │          └── Charlie: 功能 C（前+后端，严格 TDD）     │   │
│  │        ↓                                            │   │
│  │  阶段 4: Tech Lead 后置工作                          │   │
│  │          ├── 代码合并                                │   │
│  │          ├── 集成测试                                │   │
│  │          └── **服务启动验证**                        │   │
│  │        ↓                                            │   │
│  │  阶段 5: /check（6 Agent 并行检查）                  │   │
│  │        ↓                                            │   │
│  │  阶段 6: /qa 测试验收                                │   │
│  │        ↓                                            │   │
│  │  测试失败？→ 自动修复 → 重新验证                      │   │
│  │  全部通过？→ 输出 <promise>COMPLETE</promise>        │   │
│  │                                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│        ↓                                                    │
│  可交付成品 + 执行报告                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**效率提升**：多人协作模式相比串行执行，效率提升 **2-5 倍**。

---

## 使用方式

### 方式 1：交互式启动（推荐首次使用）

```bash
/auto-dev
```

Claude 会引导你：
1. 确认需求文档路径
2. 设置迭代上限（默认 30 次）
3. 确认技术栈和约束
4. 启动自动开发

### 方式 2：直接启动

```bash
/auto-dev docs/需求文档/PRD_xxx.md --max-iterations 30
```

### 方式 3：命令行启动（过夜运行）

```bash
# 在项目目录下执行
~/.claude/skills/自动开发_auto-dev/scripts/auto-dev.sh \
  --prd docs/需求文档/PRD_xxx.md \
  --max-iterations 50 \
  --log .claude/auto-dev.log
```

---

## 前置条件

### 1. 需求文档

需要一份清晰的需求文档，包含：

```markdown
# [功能名称]

## 背景
[为什么要做]

## 目标
[要实现什么]

## 功能要求
1. [具体功能点]
2. [具体功能点]
...

## 技术约束
- [技术栈要求]
- [性能要求]
- [安全要求]

## 验收标准
- [ ] [可验证的条件]
- [ ] [可验证的条件]
```

### 2. 项目环境

- 项目已初始化（git、依赖配置）
- CLAUDE.md 存在（技术栈、规范说明）
- 测试框架已配置（pytest/vitest 等）

---

## 执行流程

### 阶段 1：设计（迭代 1）

1. **读取需求文档**
2. **执行 /explore**：调研最佳实践（至少 5 个来源）
3. **执行 /design**：输出架构设计
4. **执行 /review**：批评者视角审查方案，找出遗漏和风险
5. **执行 /plan**（v3.0）：输出多人协作实施计划
   - 识别可并行的独立功能
   - 分配开发者（Alice/Bob/Charlie）
   - 指定文件范围（避免冲突）
6. **保存设计文档到 docs/ 目录**

### 阶段 2：Tech Lead 前置工作

1. **搭建基础设施**
   - 数据库 Schema
   - 中间件/拦截器
   - 路由配置
   - 前端 Context/Store
2. **验证基础设施**
   - 数据库连接正常
   - 服务能启动（不报错）

### 阶段 3：开发者并行执行（核心提效）

**同时启动多个子代理（使用 Task 工具并行）**：

```
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   Alice     │  │    Bob      │  │   Charlie   │
│  登录功能   │  │  注册功能   │  │  密码重置   │
│ (前+后端)   │  │ (前+后端)   │  │ (前+后端)   │
│ 严格 TDD    │  │ 严格 TDD    │  │ 严格 TDD    │
└─────────────┘  └─────────────┘  └─────────────┘
```

**每个开发者必须**：
- 🔴 **严格 TDD**：先看到测试失败，再写实现（见 `TDD规范.md`）
- ✅ **完成前验证**：亲眼看到验证命令成功（见 `完成前验证.md`）
- 🚧 **文件边界**：只修改分配的文件，不越界

### 阶段 4：Tech Lead 后置工作（铁律）

1. **代码合并与冲突检测**
2. **集成测试**
3. **服务启动验证**（铁律）
   ```bash
   # 必须亲眼看到服务正常启动并响应请求
   python -m uvicorn app.main:app &
   sleep 3
   curl -f http://localhost:8000/health  # 必须看到 200 OK
   ```
4. **E2E 测试**（如适用）

### 阶段 5：检查（6 Agent 并行）

1. **执行 /check**（v3.0）：
   - Agent1: 铁律检查
   - Agent2: 后端自动化
   - Agent3: 前端自动化
   - Agent4: 代码质量审查
   - Agent5: 文档同步检查
   - **Agent6: 服务启动验证**

### 阶段 6：测试验收

1. **执行 /qa**：等价类、边界值、决策表测试
2. **核对验收标准**：逐项确认

### 阶段 7：修复（如有问题）

1. **分析失败原因**（使用 /debug）
2. **修复问题**（严格 TDD，不能跳过）
3. **完成前验证**（必须亲眼看到成功）
4. **重新执行 /check**（回到阶段 5）
5. **循环直到通过**

### 阶段 8：完成

以下条件**全部满足**时才算完成：

- [ ] 所有开发者的 TDD 执行记录完整（每个测试都先看到失败）
- [ ] 所有开发者的完成前验证都通过
- [ ] **服务启动验证通过**（亲眼看到服务正常运行）
- [ ] /check 通过（6 Agent 全绿）
- [ ] /qa 验收通过
- [ ] 验收标准全部满足
- [ ] 输出完成标记：`<promise>COMPLETE</promise>`

---

## 完成条件（铁律）

以下条件**全部满足**时才算完成：

```markdown
## 开发质量
- [ ] 遵循了严格 TDD（每个测试都先看到失败）
- [ ] 完成前验证都通过（亲眼看到验证命令成功）
- [ ] 文件边界约束遵守（每个开发者只改自己的文件）

## 自动化验证
- [ ] 所有测试通过（pytest/vitest 输出 PASSED）
- [ ] 无 lint 错误（ruff/eslint）
- [ ] 无类型错误（mypy/tsc）

## 服务验证
- [ ] **服务启动验证通过**（亲眼看到服务正常运行）
- [ ] 健康检查端点响应 200
- [ ] 核心 API 能正常响应

## Skills 验证
- [ ] /check 检查通过（6 Agent 全绿）
- [ ] /qa 验收通过（等价类、边界值测试）
- [ ] 验收标准全部满足
```

**危险信号**（出现则必须重新验证）：
- "应该有效" → 确信不是验证，运行命令
- "测试太慢跳过" → 调试 bug 需要更长时间
- "服务能启动" → 必须亲眼看到健康检查通过

---

## 安全机制

### 1. 迭代上限

```bash
--max-iterations 30  # 默认 30 次，防止无限循环
```

### 2. 成本控制

```bash
--max-budget-usd 50  # 可选：设置最大 API 成本
```

### 3. 中断恢复

- 进度保存在 git 历史和日志文件中
- 中断后手动检查进度，重新运行即可（Claude 会读取 git log 识别已完成的工作）

### 4. 日志记录

```bash
# 日志文件
.claude/auto-dev.log       # 主日志
.claude/auto-dev-detail.md # 详细执行记录
```

---

## 监控方式

### 实时监控

```bash
# 查看当前状态
tail -f .claude/auto-dev.log

# 查看详细执行记录
cat .claude/auto-dev-detail.md | tail -100

# 查看 git 提交历史
git log --oneline -20
```

### 进度检查

```bash
# 查看已完成的 Tasks
grep -E "^\- \[x\]" docs/开发文档/plan_*.md

# 查看测试状态
pytest --collect-only | head -20
```

---

## 与其他 Skills 的关系

```
┌─────────────────────────────────────────────────────────────┐
│                     /auto-dev 内部调用                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  /explore（方案探索）                                        │
│      ↓                                                      │
│  /design（架构设计）                                         │
│      ↓                                                      │
│  /review（方案评审）← 批评者视角审查                          │
│      ↓                                                      │
│  /plan（写计划）                                             │
│      ↓                                                      │
│  实现代码（TDD 驱动，类似 /run-plan 但更自主）                │
│      ↓                                                      │
│  /check（开发检查）                                          │
│      ↓                                                      │
│  /qa（测试验收）← 等价类、边界值测试                          │
│      ↓                                                      │
│  循环修复直到通过                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘

手动流程：/clarify → /explore → /design → /review → /plan → /run-plan → /check → /qa → /ship
自动流程：/clarify → /auto-dev（内含全部环节）→ /ship
```

**注意**：
- `/clarify` 仍建议手动执行（需要人工确认需求）
- `/ship` 建议手动执行（最终交付需人工确认）

---

## 适用场景

### ✅ 适合使用

| 场景 | 说明 |
|------|------|
| 需求清晰的新功能 | 有完整 PRD，验收标准明确 |
| 独立模块开发 | 与现有代码耦合度低 |
| CRUD 类功能 | API、后台管理页面 |
| 过夜运行 | 白天写需求，晚上跑 |

### ❌ 不适合使用

| 场景 | 原因 | 替代方案 |
|------|------|---------|
| 需求模糊 | 无法自动澄清 | 先 /clarify |
| 复杂重构 | 需要人工判断 | /refactor |
| 紧急 Bug | 需要快速响应 | /debug |
| 核心架构改动 | 风险高 | 手动流程 |

---

## 最佳实践

### 1. 需求文档要详细

❌ **不好**：
```
实现用户管理功能
```

✅ **好**：
```markdown
# 用户管理功能

## 功能要求
1. 用户列表：分页、搜索、排序
2. 创建用户：表单验证、唯一性检查
3. 编辑用户：部分更新
4. 删除用户：软删除、确认提示

## 技术约束
- 后端：FastAPI + SQLAlchemy
- 前端：React + Ant Design
- 认证：JWT

## 验收标准
- [ ] 所有 API 端点实现（GET/POST/PUT/DELETE）
- [ ] 前端页面完成（列表、表单、详情）
- [ ] 单元测试覆盖率 > 80%
- [ ] E2E 测试通过
```

### 2. 设置合理的迭代上限

| 功能规模 | 建议迭代 | 预估成本 |
|---------|---------|---------|
| 小功能（1-3 文件） | 10-15 次 | $10-30 |
| 中等功能（5-10 文件） | 20-30 次 | $30-80 |
| 大功能（10+ 文件） | 40-60 次 | $80-150 |

### 3. 分阶段执行

对于大型功能，建议拆分：

```bash
# 阶段 1：后端 API
/auto-dev docs/PRD_用户管理_后端.md --max-iterations 30

# 阶段 2：前端页面
/auto-dev docs/PRD_用户管理_前端.md --max-iterations 30
```

---

## 故障处理

### 1. 迭代用完但未完成

```bash
# 检查当前状态
cat .claude/auto-dev-detail.md | tail -50

# 增加迭代继续（Claude 会自动识别已完成的工作）
~/.claude/skills/自动开发_auto-dev/scripts/auto-dev.sh \
  --prd docs/需求文档/PRD_xxx.md \
  --max-iterations 20
```

### 2. 测试一直失败

```bash
# 手动介入调试
/debug

# 修复后重新运行（Claude 会识别 git 历史，不会重复已完成的工作）
/auto-dev docs/需求文档/PRD_xxx.md
```

### 3. 卡在某个步骤

```bash
# 查看日志定位问题
cat .claude/auto-dev.log | tail -100

# 手动执行该步骤
/check  # 或其他卡住的步骤

# 重新运行自动开发
/auto-dev docs/需求文档/PRD_xxx.md
```

---

## 输出物

执行完成后，你会得到：

1. **可运行的代码**：符合需求的完整实现
2. **测试用例**：单元测试、集成测试
3. **设计文档**：`docs/设计文档/设计_[功能名].md`
4. **执行报告**：`.claude/auto-dev-detail.md`
5. **git 历史**：每个步骤的提交记录

---

## ✅ 完成提示

当自动开发完成后，输出：

```
✅ 自动开发完成（往死里干模式）

📊 执行统计：
   - 执行模式: 多人协作（效率提升 2-5 倍）
   - 开发者团队: Alice, Bob, Charlie
   - 总迭代次数: X
   - 生成文件数: X
   - 测试用例数: X
   - 总耗时: X 分钟

🔧 开发者完成情况：
   - Alice (登录功能): ✅ TDD 通过, 验证通过
   - Bob (注册功能): ✅ TDD 通过, 验证通过
   - Charlie (密码重置): ✅ TDD 通过, 验证通过

🏥 服务验证：
   - 服务启动: ✅ 正常
   - 健康检查: ✅ 200 OK
   - 核心 API: ✅ 响应正常

✅ Skills 检查：
   - /check: ✅ 6 Agent 全绿
   - /qa: ✅ 验收通过

🎯 下一步建议：
   1. 人工验收确认（/qa 已自动执行）
   2. 执行 /ship 提交代码
```

---

**技能版本**: v2.0（往死里干模式）
**更新日期**: 2025-01-28
**核心理念**:
- 多人协作模式（效率提升 2-5 倍）
- 严格 TDD（没有先失败的测试，就没有生产代码）
- 完成前验证（亲眼看到验证命令成功）
- 服务启动验证（亲眼看到服务正常运行）
