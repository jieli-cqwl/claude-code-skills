# 需求澄清：Claude Code 人机协作模式重建

**澄清日期**：2026-02-13
**状态**：已确认

---

## 1. 背景

我是产研负责人，使用 Claude Code 作为研发执行团队。现状：同样的需求，我的产出效率和质量不如同样使用 Claude Code 的朋友（更慢、Bug 更多）。

### 根因分析（经苏格拉底对话确认）

| 根因 | 证据 | 优先级 |
|------|------|--------|
| 需求澄清质量不足 | /clarify 只做"对齐理解"不做"挑战方向"，输出的 AC 是人可理解粒度但不是机器可无歧义执行粒度 | 最大因素 |
| 自主执行过程质量泄漏 | 单会话跑全流程导致上下文臃肿；同一模型不会质疑自己前序输出；上下文压缩丢失早期要求 | 第二因素 |
| 配置臃肿分散注意力 | 31 Skills / 14 Hooks / 194 行 Rules，基础设施占上下文 8-11%，每个 Skill 内容存在形式主义 | 第三因素 |
| 虚假完成是模型固有倾向 | Claude 倾向于过度自信声称完成，Hook 能挡住"测试没过"但挡不住"做错了东西但测试恰好通过" | 第四因素 |

### 关键发现

- **配置不是主因**：朋友分享了同样的配置，我用了仍不如他们，说明配置差异不是核心
- **使用方式是主因**：我只看结果不看过程，所有需求一刀切走全流程，不在中间纠偏
- **Skills 存在形式主义**：流程走完了、模板填满了，但没产生真正的价值判断

---

## 2. 目标

**一句话**：我只负责把需求说清楚和最终验收交付，中间的设计、开发、测试、修复全部由 Claude Code 自主高质量完成。

**决策模型**：
- 开头：需求澄清（我深度参与）
- 结尾：判断是否交付（我最终验收）
- 中间：全流程自动化，异常时暂停通知我

---

## 3. 要解决的问题

### P0：需求澄清的质量不足以支撑自主执行

- **现状**：/clarify 做的是"对齐理解"，不做"挑战方向"；输出的 AC 是人能理解的粒度，但不是 Claude Code 能无歧义执行的粒度
- **目标**：澄清完成后的文档，具体到 Claude Code 可以不问任何问题直接走完全流程
- **关键改变**：
  - /clarify 需要具备反向挑战能力（质疑需求方向是否正确）
  - 输出粒度对齐"机器可执行"而非"人可理解"
  - 每个 AC 必须具体到实现方式、边界条件、验证方法都无歧义

### P1：自主执行流程的可靠性

- **现状**：单会话跑全流程导致上下文臃肿、质量泄漏、虚假完成
- **目标**：每个环节独立上下文，文档留痕串联，异常有保护机制
- **完整流程**：

```
/clarify（用户深度参与）
    ↓ 输出留痕文档 → 清上下文
/design（自动）
    ↓ 输出留痕文档 → 清上下文
/plan（自动）
    ↓ 输出留痕文档 → 清上下文
/run-plan（自动）
    ↓ 输出留痕文档 → 清上下文
/check（自动）
    ↓ 输出留痕文档 → 清上下文
/qa（自动）
    │
    ├─ 不通过 → /fix → /check → /qa（最多循环 10 次）
    │
    ├─ 10 次仍不通过 → 暂停通知用户
    │
    └─ 通过 → 等待用户验收
        ↓
/ship（用户确认后执行）
```

- **上下文管理**：每个环节完成后输出留痕文档 → 清空上下文 → 下个环节读留痕文档启动
- **异常处理**：中间任何环节异常（包括输出格式缺失、预期文件未生成、校验不通过）→ 强行中断（触发 `exit 1`）并通知用户，绝不静默放行或允许“带病跑完全程”。
- **反虚假完成（客观验证）**：彻底废弃基于自然语言（如检查是否输出 `RESULT: PASS`）的校验。流程往下推进的唯一凭证是**物理级别的客观证据**（如测试框架返回的退出码、生成的覆盖率文件、或是脚本强制写入的防伪通行证 `test_pass_flag`）。
- **自动化实现**：通过 Claude Code CLI 脚本编排，并配备可靠的子进程树强杀隔离机制（如 `gtimeout --signal=KILL` 取代有僵尸进程后患的 `perl alarm`）。

### P2：配置质量（P1 的前提条件）

- **现状**：31 Skills / 14 Hooks / 194 行 Rules，内容存在形式主义，不是每个 Skill 都真正有效
- **目标**：每个 Skill 和 Rule 的存在标准是"是否真正提升执行质量"，无效内容删除，有效内容精炼保留
- **核心标准是质量，不是数量**：不是为了"从 31 砍到 10"这个数字好看，而是保留的每一个必须真正能指导高质量执行

---

## 4. 需要调研的关键技术问题

| 编号 | 问题 | 说明 |
|------|------|------|
| R1 | Claude Code CLI 能否支持脚本编排多会话 | claude -p 串联、headless mode、会话间传递文档等 |
| R2 | 每步"清上下文 + 文档留痕"的最佳实现方式 | 怎么确保留痕文档足够完整，下一步能无损接续 |
| R3 | 异常检测和暂停通知的实现机制 | 怎么判断某个环节"异常"了，怎么通知用户 |
| R4 | fix 循环的自动化控制 | 循环计数、终止条件、每轮 fix 的上下文隔离 |

---

## 5. 共识

| 条目 | 说明 |
|------|------|
| 完整流程保留 | 不砍环节（clarify → design → plan → run-plan → check → qa → fix → ship），让每个环节做到位 |
| Claude Code 能胜任执行角色 | 知识储备比单个真人广，配合流程和规则可以比真人更强 |
| 质量是核心标准 | Skill/Rule 的存在标准是"是否提升执行质量"，不是数量多少 |
| 用户愿意改变使用方式 | 把精力集中在需求澄清，不再每步都手动触发 |

---

## 6. 排除项

| 条目 | 原因 |
|------|------|
| 不额外增加独立评审层（如 /critique、/gemini-critique） | Pipeline 内 Checker/QA 角色张力已提供质量对抗，额外评审层边际价值低，且增加流程复杂度 |
| 不追求实时介入每个环节 | 与"只介入首尾"的目标矛盾 |
| 不考虑 Claude Code CLI 以外的平台方案 | 本次调研范围限定 |

---

## 7. 交付物预期

- **最终结果**：可运行的代码 + 测试通过报告
- **中间留痕**：每个环节的输出文档（clarify doc → design doc → plan doc → 各阶段 report → qa report）

---

## 8. 与 v1 的关键差异

| 维度 | v1（原版） | v2（本版） |
|------|-----------|-----------|
| 问题定义 | 诊断 Claude Code 配置问题 | 重建人机协作模式 |
| 核心归因 | 配置臃肿、token 开销大 | 需求输入质量 + 执行过程可靠性 |
| 解法方向 | 精简配置（31→10 Skills） | 提升 clarify 质量 + 自动化流程编排 + 配置质量提升 |
| 用户角色 | 每步手动触发 Skill | 只介入首尾（澄清 + 验收） |
| 自动化方式 | /auto-dev（单会话状态机） | CLI 脚本编排（多会话、独立上下文、文档串联） |
