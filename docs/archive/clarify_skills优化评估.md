# Skills 优化需求评估

**评估日期**：2026-01-30
**状态**：客观分析中

---

## 需求 1："简单、合适、演化"原则

### 现状分析

**该原则已存在于 `/refactor` skill**（refactor/skill.md:13, 46-77）：
- **简单原则**：不过度设计（YAGNI - You Aren't Gonna Need It）
- **合适原则**：该复杂时复杂，该简单时简单
- **演化原则**：根据实际需求演化，而非预设

**架构设计的现有原则**（design/skill.md:86-94）：
- 单一职责
- 接口先行
- 数据驱动
- 最小依赖
- 可测试性

### 对比分析

| 维度 | 现有原则 | "简单、合适、演化" |
|------|---------|------------------|
| **层次** | 技术实现层面 | 设计哲学层面 |
| **关注点** | 如何设计（模块、接口、数据） | 设计到什么程度 |
| **作用** | 指导具体设计决策 | 防止过度设计/设计不足 |
| **关系** | 具体原则 | 元原则（指导其他原则的应用） |

### 价值评估

✅ **有价值**：
- 防止过度设计（架构设计的常见问题）
- 提供"设计到什么程度"的判断标准
- 与现有原则互补，不冲突

✅ **有用**：
- 在重构场景已验证有效（refactor/skill.md）
- 可以指导架构设计时的决策（如"要不要加这个抽象层？"）

⚠️ **但需要明确定位**：
- 不是与其他 5 个原则并列的"第 6 个原则"
- 是"元原则"，指导其他原则的应用
- 类似于重构 skill 中的定位（核心理念）

### 建议

**✅ 应该加入架构设计**，但需要正确定位：

1. **位置**：放在"核心原则"章节的最前面，作为"设计哲学"
2. **表述**：
   ```markdown
   ## 设计哲学：简单、合适、演化

   > 架构设计的核心是"恰到好处"，而非"越复杂越好"或"越简单越好"

   - **简单**：不过度设计，避免"万一将来需要"的预设
   - **合适**：该复杂时复杂（业务本身复杂），该简单时简单
   - **演化**：根据实际需求演化，重复 3 次再抽象

   以下 5 个原则在应用时，都应遵循"简单、合适、演化"的哲学。
   ```

3. **应用示例**：
   - 单一职责 + 简单原则 → 不要为了"单一职责"过度拆分模块
   - 接口先行 + 合适原则 → 只有多个实现时才抽象接口
   - 最小依赖 + 演化原则 → 依赖关系根据实际需求演化，不预设

---

## 需求 2：评审流程复杂度

### 现状分析

**当前设计**（critique/skill.md:120-143）：
- 10 个评审维度 → 合并为 5 个评审组 → 5 个并行 Agent
- 结构化 JSON 输出 + 错误处理 + 一致性校验
- Phase 1-4：识别对象 → 读取规范 → 并行评审 → 汇总输出

**复杂度来源**：
1. 并行 Agent 数量：5 个
2. 评审维度：10 个（合并为 5 组）
3. 输出格式：结构化 JSON
4. 错误处理：超时、失败、部分失败
5. 流程阶段：4 个 Phase

### 客观评估

#### 1. 评审维度（10 个）是否合理？

✅ **完全合理，不应减少**：

| 维度 | 必要性 | 如果去掉会怎样 |
|------|--------|--------------|
| 完整性 | ✅ 必要 | 遗漏场景和边界情况 |
| 一致性 | ✅ 必要 | 方案内部矛盾 |
| 可行性 | ✅ 必要 | 技术上无法实现 |
| 风险 | ✅ 必要 | 并发、竞态等问题 |
| 遗漏分析 | ✅ 必要 | 缺少必要功能 |
| 技术债务 | ✅ 必要 | 难以维护的设计 |
| 安全性 | ✅ 必要 | 安全漏洞 |
| 性能影响 | ✅ 必要 | 性能问题 |
| 可维护性 | ✅ 必要 | 代码难以理解 |
| 用户体验 | ✅ 必要 | 用户使用不便 |

**结论**：10 个维度都是方案评审的必要维度，没有冗余。

#### 2. 5 个并行 Agent 是否合理？

**对比其他 skill 的并行策略**：

| Skill | 并行 Agent 数量 | 任务类型 |
|-------|----------------|---------|
| `/refactor` | 10 + 10 = 20 个 | 检测 + 建议 |
| `/design` | 1 + 6 = 7 个 | 数据模型 + 各层设计 |
| `/critique` | 5 个 | 评审 |

✅ **5 个 Agent 并不算多**：
- 相比 `/refactor` 的 20 个、`/design` 的 7 个，5 个是合理的
- 并行执行比串行快 5 倍
- 每个 Agent 负责 2 个相关维度，职责明确

✅ **合并策略合理**：
- 完整性 + 遗漏分析（都在检查"缺了什么"）
- 一致性 + 可行性（都在检查"方案能否落地"）
- 风险 + 安全性（都在分析"可能出什么问题"）
- 技术债务 + 可维护性 + 性能（都属于"工程质量"）
- 用户体验（独立维度）

**结论**：5 个 Agent 是合理的，不应减少。

#### 3. 结构化 JSON 输出是否必要？

✅ **必要**：
- 需要汇总多个 Agent 的结果
- 结构化输出便于解析和汇总

❌ **但对用户无价值**：
- 用户只看最终的 Markdown 报告
- JSON 格式是内部实现细节

**改进方向**：将 JSON 格式描述移到"实现细节"章节。

#### 4. 错误处理是否过度？

✅ **必要**：
- 并行执行必须处理超时和失败
- 部分失败时继续执行，全部失败时报错

❌ **但描述过细**：
- 文档中的错误处理表格让人觉得复杂
- 这些是实现细节，不应放在主流程中

**改进方向**：简化错误处理的描述，只保留关键信息。

### 真正的问题

❌ **不是设计复杂**：5 个 Agent、10 个维度、并行执行都是必要的
❌ **不是功能冗余**：每个评审维度都有独特价值
✅ **真正的问题**：**文档描述过于详细，让人觉得复杂**

**证据**：
1. 错误处理表格占了大量篇幅（critique/skill.md:192-204）
2. Agent 输出格式的 JSON 示例很长（critique/skill.md:169-190）
3. 并行策略的解释很详细（critique/skill.md:120-143）

### 改进建议

✅ **保持设计不变**（质量和效率都需要）：
- 5 个并行 Agent
- 10 个评审维度
- 结构化输出和错误处理

✅ **简化文档描述**（降低感知复杂度）：
1. 将错误处理细节移到"实现细节"章节
2. 简化 Agent 输出格式的描述
3. 强调"用户视角"：用户只需要看最终报告

**修改前**（当前）：
```markdown
### Phase 3: 并行评审（5 Agent）

> 并行策略：将 10 个评审维度合并为 5 个互补的评审组...
> [详细的 Agent 分配表]
> [详细的 Prompt 模板]
> [详细的 JSON 输出格式]
> [详细的错误处理规范]
```

**修改后**（简化）：
```markdown
### Phase 3: 并行评审（5 Agent）

同时启动 5 个评审 Agent，分别负责：
1. 需求覆盖（完整性 + 遗漏分析）
2. 方案一致性（一致性 + 可行性）
3. 风险安全（风险 + 安全性）
4. 工程质量（技术债 + 可维护性 + 性能）
5. 用户视角（用户体验）

每个 Agent 独立评审，最终汇总输出报告。

> 实现细节见附录 A
```

---

## 总结

### 需求 1："简单、合适、演化"原则

✅ **应该加入架构设计**
- 作为"设计哲学"放在最前面
- 指导其他 5 个原则的应用
- 防止过度设计

### 需求 2：评审流程复杂度

✅ **设计本身是合理的，不应该简化**
- 5 个 Agent、10 个维度都是必要的
- 简化会降低评审质量或效率
- 真正的问题是文档描述过于详细

❌ **不要为了简化而简化**
- 质量：10 个评审维度保证全面性
- 效率：5 个并行 Agent 保证速度
- 改进方向：简化文档，而不是简化设计

---

## 下一步

请确认以上分析是否正确：

1. **"简单、合适、演化"原则**应该作为设计哲学加入架构设计？
2. **评审流程**的设计是合理的，只需要简化文档描述？
3. 是否同意"不为了简化而简化，质量和效率都需要"的原则？

确认后我可以开始修改相关文档。
