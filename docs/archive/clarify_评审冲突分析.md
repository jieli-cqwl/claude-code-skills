# 评审流程冲突分析

**分析日期**：2026-01-30
**发现者**：用户
**问题**：评审流程与项目规范存在冲突，可能导致过度设计

---

## 冲突发现

### 冲突点 1：缓存策略

**评审中的表述**（critique/skill.md:278）：
```markdown
| 没有缓存 | 每次操作都很慢，用户体验差 |
```

**规范中的要求**（性能效率.md:21-45）：
```markdown
## ⚠️ 缓存策略（需人工确认）

> **铁律**：任何缓存引入必须经用户明确同意，Claude Code 不得自行添加缓存。

### 为什么早期不加缓存
- 幽灵 Bug：数据不一致、看到旧数据，难以定位
- 调试成本：每次都要排查"是缓存问题还是代码问题"
- 失效策略难：早期业务逻辑频繁变动，缓存失效策略难以正确设计
- 过早优化：系统未稳定时优化是浪费

### 何时加缓存
- ✅ 系统功能稳定，进入**性能优化阶段**
- ✅ 有明确的**性能瓶颈数据**支撑（如 API 响应 > 1s）
- ✅ 用户**明确同意**引入缓存
```

**冲突分析**：
- ❌ 评审把"没有缓存"当作问题
- ✅ 规范明确说"早期不加缓存"
- ❌ 这会导致评审要求在开发阶段就加缓存（过度设计）

---

## 用户的思考

> "前期应该聚焦核心（合理性、必要埋坑等，让后面能进行演化），而不是一开始就考虑并发、性能等（可能过度设计）"

### 这个思考是否正确？

✅ **完全正确**，这正是"简单、合适、演化"原则的核心：

| 阶段 | 应该关注 | 不应该关注 |
|------|---------|-----------|
| **开发阶段** | 功能正确性、代码可读性、必要的扩展点 | 性能优化、缓存、并发控制 |
| **稳定阶段** | 代码质量、测试覆盖 | 过度抽象、预设扩展 |
| **优化阶段** | 性能瓶颈、缓存策略 | 功能重构 |

**"必要埋坑"的含义**：
- ✅ 接口设计合理，方便未来扩展
- ✅ 模块边界清晰，方便未来拆分
- ✅ 数据模型有扩展字段（如 JSON 字段）
- ❌ 不是提前实现缓存、并发控制等

---

## 系统性分析

### 1. 评审的职责边界

**评审应该检查什么？**

| 阶段 | 应该检查 | 不应该检查 |
|------|---------|-----------|
| **开发阶段** | 功能完整性、逻辑正确性、代码质量、安全漏洞 | 性能优化、缓存策略、并发控制 |
| **优化阶段** | 性能瓶颈、缓存策略、并发控制 | 功能完整性（已完成） |

**当前评审的问题**：
- ❌ 在开发阶段就检查"没有缓存"
- ❌ 在开发阶段就检查"没有并发控制"
- ❌ 没有区分"开发阶段"和"优化阶段"

---

### 2. 哪些是过度设计？

**对比分析**：

| 评审项 | 开发阶段 | 优化阶段 | 是否过度设计 |
|--------|---------|---------|-------------|
| **缺少异常处理** | ✅ 必须检查 | ✅ 必须检查 | ❌ 不是 |
| **N+1 查询** | ✅ 必须检查 | ✅ 必须检查 | ❌ 不是（基本质量） |
| **缺少事务控制** | ✅ 必须检查 | ✅ 必须检查 | ❌ 不是（数据一致性） |
| **没有并发控制** | ⚠️ 看场景 | ✅ 必须检查 | ⚠️ 可能是（如果业务不需要） |
| **缺少重试机制** | ⚠️ 看场景 | ✅ 必须检查 | ⚠️ 可能是（如果不是关键路径） |
| **没有缓存** | ❌ 不应检查 | ✅ 必须检查 | ✅ **是**（早期过度设计） |
| **接口没有限流** | ❌ 不应检查 | ✅ 必须检查 | ✅ **是**（早期过度设计） |

**结论**：
- ✅ 异常处理、事务控制、N+1 查询 → **基本质量要求**，不是过度设计
- ⚠️ 并发控制、重试机制 → **看业务场景**，不是所有场景都需要
- ❌ 缓存、限流 → **性能优化阶段**才需要，早期是过度设计

---

### 3. "简单、合适、演化"的应用

**在评审中如何体现？**

#### 简单原则
- ✅ 检查是否过度抽象（如只有一个实现却定义了接口）
- ✅ 检查是否过度拆分（如模块过多导致理解困难）
- ✅ 检查是否有不必要的设计模式

#### 合适原则
- ✅ 检查设计是否匹配当前需求（不多不少）
- ✅ 检查是否为"将来可能需要"预设了功能
- ✅ 检查复杂度是否与业务复杂度匹配

#### 演化原则
- ✅ 检查是否有必要的扩展点（接口、配置）
- ✅ 检查模块边界是否清晰（方便未来拆分）
- ❌ 不检查是否提前实现了未来功能

---

### 4. 评审维度的重新分类

**按阶段分类**：

#### 开发阶段（必须检查）
| 维度 | 检查内容 |
|------|---------|
| **完整性** | 功能是否完整、边界情况是否处理 |
| **一致性** | 方案内部是否一致、与需求是否一致 |
| **可行性** | 技术上是否可实现 |
| **遗漏分析** | 是否遗漏必要功能 |
| **安全性** | 是否有安全漏洞（SQL 注入、XSS 等） |
| **可维护性** | 代码是否易读、模块是否清晰 |
| **用户体验** | 操作是否友好、错误提示是否清晰 |

#### 优化阶段（性能优化时检查）
| 维度 | 检查内容 |
|------|---------|
| **性能影响** | 是否有性能瓶颈（N+1、全表扫描） |
| **缓存策略** | 是否需要缓存、失效策略是否合理 |
| **并发控制** | 是否需要并发控制、锁策略是否合理 |
| **限流策略** | 是否需要限流、限流策略是否合理 |

#### 风险评估（始终检查，但不强制修复）
| 维度 | 检查内容 |
|------|---------|
| **技术债务** | 是否有技术债务、是否可接受 |
| **风险** | 是否有潜在风险、是否有缓解措施 |

---

## 改进建议

### 1. 评审维度调整

**修改"业务语言翻译表"**（critique/skill.md:270-280）：

**修改前**：
```markdown
| 没有缓存 | 每次操作都很慢，用户体验差 |
| 接口没有限流 | 被恶意调用时系统会崩溃 |
```

**修改后**：
```markdown
| 没有缓存 | [性能优化阶段] 每次操作都很慢，用户体验差 |
| 接口没有限流 | [性能优化阶段] 被恶意调用时系统会崩溃 |
| 没有并发控制 | [看场景] 多人同时操作时可能互相覆盖，数据丢失 |
```

### 2. 增加"阶段感知"

**在评审开始前，先判断当前阶段**：

```markdown
### Phase 0: 识别阶段（新增）

> 根据评审对象判断当前处于哪个阶段

**判断依据**：
- 如果是 /design 或 /plan 输出 → **开发阶段**
- 如果是 /perf 或性能优化需求 → **优化阶段**
- 如果是重构需求 → **稳定阶段**

**评审策略**：
- **开发阶段**：聚焦功能正确性、代码质量、安全性
- **优化阶段**：聚焦性能、缓存、并发、限流
- **稳定阶段**：聚焦可维护性、技术债务
```

### 3. 修改评审维度

**将 10 个维度重新分类**：

#### 核心维度（所有阶段）
1. 完整性
2. 一致性
3. 可行性
4. 遗漏分析
5. 安全性
6. 可维护性
7. 用户体验

#### 优化维度（优化阶段）
8. 性能影响
9. 缓存策略（新增）
10. 并发控制（新增）

#### 风险维度（始终评估，但不强制修复）
11. 技术债务
12. 风险

**评审策略调整**：
- **开发阶段**：只评审核心维度（1-7）+ 风险维度（11-12）
- **优化阶段**：评审所有维度（1-12）

### 4. 增加"过度设计"检查

**在评审中增加"简单、合适、演化"检查**：

```markdown
### 评审维度：设计合理性（新增）

**检查内容**：
- [ ] 是否有不必要的抽象（只有一个实现却定义了接口）
- [ ] 是否有不必要的设计模式（如单例、工厂、策略等）
- [ ] 是否为"将来可能需要"预设了功能
- [ ] 是否在开发阶段就加了缓存、限流等优化
- [ ] 模块拆分是否过细（导致理解困难）

**业务语言**：
| 技术描述 | 业务语言 |
|---------|---------|
| 只有一个实现却定义了接口 | 代码过度抽象，增加理解成本 |
| 开发阶段就加了缓存 | 过早优化，增加调试难度 |
| 为未来需求预设功能 | 代码复杂度高，维护成本大 |
```

---

## 总结

### 用户的思考是正确的

✅ **前期应该聚焦核心**：
- 功能正确性
- 代码可读性
- 必要的扩展点（接口设计、模块边界）

❌ **前期不应该关注**：
- 性能优化（缓存、限流）
- 并发控制（除非业务必需）
- 过度抽象（预设未来需求）

### 评审存在的问题

❌ **没有区分阶段**：
- 在开发阶段就检查"没有缓存"
- 在开发阶段就检查"没有限流"

❌ **与规范冲突**：
- 规范说"早期不加缓存"
- 评审说"没有缓存是问题"

### 改进方向

✅ **增加阶段感知**：
- 开发阶段：聚焦功能、质量、安全
- 优化阶段：聚焦性能、缓存、并发

✅ **增加"过度设计"检查**：
- 检查是否过度抽象
- 检查是否过早优化
- 检查是否为未来预设功能

✅ **遵循"简单、合适、演化"原则**：
- 简单：不过度设计
- 合适：匹配当前需求
- 演化：有必要的扩展点

---

## 下一步

请确认以上分析是否正确：

1. **冲突确实存在**：评审要求"没有缓存是问题"，但规范说"早期不加缓存"
2. **用户的思考是正确的**：前期聚焦核心，不过度设计
3. **改进方向**：增加阶段感知 + 增加"过度设计"检查

确认后我可以修改评审流程。
