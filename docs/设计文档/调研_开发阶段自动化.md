# 开发阶段自动化 (dev-loop) 方案调研

**日期**：2026-02-04
**状态**：已确认
**AC 来源**：`docs/需求澄清/clarify_开发阶段自动化.md`

---

## 1. 背景

用户希望将真实研发流程中的"开发阶段"自动化，创建 `/dev-loop` Skill，封装：
- 开发编码（run-plan）
- 代码自检（check）
- 代码评审（gemini-review）
- 评审不通过时的自动修复循环（最多 3 次）

---

## 2. 业界调研

### 2.1 调研来源汇总（8 个 Agent 并行）

| 来源 | 核心发现 | 匹配度 |
|------|---------|--------|
| **GitHub 开源** | Continuous Claude、Ralph Wiggum（Agentic Loop） | ⭐⭐⭐⭐⭐ |
| **技术博客** | Red Queen Pattern（规则驱动）、Double Loop Model | ⭐⭐⭐⭐⭐ |
| **Stack Overflow** | 指数退避重试、错误分类、幂等性 | ⭐⭐⭐⭐ |
| **官方文档** | ruff --fix、eslint --fix、pytest-retry | ⭐⭐⭐⭐ |
| **企业博客** | Uber uReview（65%采纳率）、Google 静态分析（3000次/天） | ⭐⭐⭐⭐⭐ |
| **学术论文** | LLM + 静态分析混合、多源反馈（提升60%） | ⭐⭐⭐⭐ |
| **中文社区** | Cursor Agent 循环、FixAgent 三层架构 | ⭐⭐⭐⭐ |
| **现有实现** | auto-dev 重试机制、run-plan 派发模式、check 并行架构 | ⭐⭐⭐⭐⭐ |

### 2.2 关键洞察

| 维度 | 业界最佳实践 | 应用到 dev-loop |
|------|-------------|-----------------|
| **循环控制** | 最大重试次数 + 指数退避 | 3 次重试，共享计数 |
| **错误分类** | 区分瞬时错误（可重试）vs 永久错误 | lint 错误自动修复，逻辑错误人工介入 |
| **自动修复** | ruff --fix + LLM 生成补丁 | 先工具修复，再 AI 修复 |
| **反馈机制** | 多源反馈（测试 + 静态分析） | check + gemini-review 双重反馈 |
| **修复采纳率** | Uber 65%、Google 3000次/天 | 目标 >70% |

---

## 3. 可行方案对比

### 方案 A：复用现有 Skills 组合（推荐）

**来源**：Agent 8（现有实现分析）

**概述**：基于已有的 auto-dev、run-plan、check 模式，封装为新 Skill，最小化开发量。

**核心思路**：
```
/dev-loop 启动
    ↓
门控检查（复用 run-plan 门控）
    ↓
调用 Skill: run-plan（执行开发）
    ↓
调用 Skill: check（代码自检）
    ↓ 失败？→ 自动修复（复用 auto-dev 重试机制）→ 重新 check
    ↓ 通过
调用 Skill: gemini-review（外部审查）
    ↓ 发现问题？→ 根据评审意见修复 → 重新 check → gemini-review
    ↓ 通过
输出完成报告
```

**优势**：
- 复用现有成熟模式（重试、并行、检查点）
- 开发量最小（约 1-2 天）
- 与现有 Skills 链路无缝集成
- 中断恢复机制可直接复用

**劣势**：
- 依赖现有 Skills 的稳定性
- 跨 Skill 调用可能有上下文传递开销

**工作量**：约 1-2 天

**风险**：
- Skill 调用开销：可通过直接读取 SKILL.md 指令而非 Skill 工具调用来优化

---

### 方案 B：Agentic Loop 模式

**来源**：Agent 1（GitHub）、Agent 2（博客）

**概述**：参考 Continuous Claude / Ralph Wiggum，构建完整的自主循环框架。

**核心思路**：
```
/dev-loop 启动
    ↓
Agent 持续运行，每轮迭代：
    1. 执行开发任务
    2. 运行测试/检查
    3. 分析失败原因
    4. 生成修复补丁
    5. 应用补丁
    6. 重复直到通过或达到最大次数
```

**优势**：
- 完全自主，最小人工干预
- 参考成熟开源实现
- 支持长时间运行（数小时）

**劣势**：
- 需要重新实现循环控制逻辑
- 与现有 Skills 重复度高
- 开发量较大（约 3-5 天）

**工作量**：约 3-5 天

**风险**：
- 无限循环风险：需要严格的退出条件

---

### 方案 C：双层循环模式

**来源**：Agent 2（博客）、Agent 5（企业博客）

**概述**：参考 Double Loop Model，分离"开发探索"和"质量保证"两个循环层。

**核心思路**：
```
第一层（开发循环）：run-plan → check
    ↓ check 通过
第二层（评审循环）：gemini-review → 修复 → check
    ↓ 评审通过
完成
```

**优势**：
- 职责分离清晰
- 避免混淆开发问题和评审问题
- 便于定位失败环节

**劣势**：
- 两层循环管理复杂
- 重试计数跨层同步困难

**工作量**：约 2-3 天

**风险**：
- 跨层状态同步

---

## 4. 方案选择

### 推荐：方案 A（复用现有 Skills 组合）

**理由**：

1. **最小开发量**：已有 auto-dev 的重试机制、run-plan 的派发模式、check 的并行架构可直接复用
2. **风险最低**：基于已验证的实现，不需要重新造轮子
3. **符合渐进式策略**：用户希望"先把每个环节自动化"，方案 A 正是将现有环节串联
4. **易于扩展**：后续可逐步增强为方案 B 的完整 Agentic Loop

**核心复用**：

| 现有模式 | 复用到 dev-loop |
|---------|----------------|
| auto-dev 重试机制 | MAX_RETRY=3，分析→修复→验证循环 |
| run-plan 门控检查 | plan 文档存在检查 |
| check 并行架构 | 9 Agent 并行检查 |
| auto-dev 检查点 | 中断恢复机制 |

---

## 5. 风险与缓解

| 风险 | 缓解措施 |
|------|---------|
| gemini CLI 不可用 | 降级为仅 check（AC-11 已定义） |
| 自动修复失败率高 | 区分错误类型：lint 错误自动修复，逻辑错误人工介入 |
| 无限循环 | MAX_RETRY=3 硬限制 + 超时 |
| 跨 Skill 上下文丢失 | 使用检查点文件传递状态 |

---

## 6. 自动修复策略

基于业界调研，推荐分层修复：

| 层级 | 问题类型 | 修复方式 | 成功率 |
|------|---------|---------|--------|
| L1 | lint/格式错误 | `ruff --fix` / `eslint --fix` | >95% |
| L2 | 类型错误 | LLM 分析 + 自动添加注解 | ~80% |
| L3 | 测试失败 | LLM 分析失败原因 + 修复代码 | ~60% |
| L4 | gemini-review 问题 | LLM 根据评审意见逐条修复 | ~70% |

**修复流程**：
```
检测到失败
    ↓
分类错误类型（L1-L4）
    ↓
按层级尝试修复
    ├─ L1: 直接调用工具命令
    └─ L2-L4: 使用 LLM 生成修复补丁
    ↓
重新运行检查
    ↓
如果仍失败，计数+1，继续循环
```

---

## 7. 下一步

执行 `/design` 生成架构设计，包括：
- 模块划分
- 接口定义
- 状态机设计
- 检查点格式

---

**调研参考来源**：
- [Continuous Claude](https://github.com/AnandChowdhary/continuous-claude)
- [Ralph Wiggum Agentic Loop](https://ralph-wiggum.ai/)
- [Uber uReview](https://www.uber.com/blog/ureview/)
- [Google Static Analysis](https://research.google/pubs/pub46576/)
- [The Red Queen Code Review Pattern](https://dev.to/haco29/the-red-queen-code-review-pattern)
- [Double Loop Model](https://testdouble.com/insights/youre-holding-it-wrong-the-double-loop-model-for-agentic-coding)
- [LLM-based Automated Program Repair Survey](https://arxiv.org/html/2506.23749v1)
- [Cursor Agent Best Practices](https://cursor.com/cn/blog/agent-best-practices)
