# 开发阶段自动化 (dev-loop) 架构设计

**设计日期**：2026-02-04
**状态**：已确认
**文档路径**：`docs/设计文档/设计_开发阶段自动化.md`

**前置文档**：
- AC 文档：`docs/需求澄清/clarify_开发阶段自动化.md`
- 调研文档：`docs/设计文档/调研_开发阶段自动化.md`

---

## 1. 技术方案

**选型**：方案 A - 复用现有 Skills 组合

**核心复用**：
| 现有模式 | 复用到 dev-loop |
|---------|----------------|
| auto-dev 重试机制 | MAX_RETRY=3，分析→修复→验证循环 |
| run-plan 门控检查 | plan 文档存在检查 |
| check 并行架构 | 9 Agent 并行检查 |
| auto-dev 检查点 | 中断恢复机制 |

---

## 2. 模块划分

### 2.1 系统边界图

```
┌─────────────────────────────────────────────────────────────────┐
│                        /dev-loop Skill                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐                                               │
│  │ 门控模块     │ ← 检查 plan 文档、gemini CLI 可用性           │
│  │ (Gate)       │                                               │
│  └──────┬───────┘                                               │
│         ↓                                                       │
│  ┌──────────────┐                                               │
│  │ 状态机模块   │ ← 控制执行流程、状态转换                      │
│  │ (StateMachine)│                                              │
│  └──────┬───────┘                                               │
│         ↓                                                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ 执行器模块   │  │ 修复器模块   │  │ 检查点模块   │          │
│  │ (Executor)   │──│ (Fixer)      │──│ (Checkpoint) │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
│         ↓                ↓                   ↓                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    外部 Skills                           │   │
│  │  /run-plan     /check     /gemini-review                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 模块职责

| 模块 | 职责 | 对外接口 | 依赖 |
|------|------|---------|------|
| **Gate（门控）** | 检查前置条件：plan 文档存在、gemini CLI 可用 | `check_gate()` | 文件系统、Bash |
| **StateMachine（状态机）** | 控制执行流程、状态转换、重试计数 | `run()`, `get_state()` | Gate, Executor, Fixer, Checkpoint |
| **Executor（执行器）** | 调用外部 Skills（run-plan, check, gemini-review） | `execute_skill()` | Skill 工具 |
| **Fixer（修复器）** | 分析错误、执行自动修复 | `analyze_and_fix()` | Bash (ruff/eslint), LLM |
| **Checkpoint（检查点）** | 保存/恢复执行状态 | `save()`, `load()` | 文件系统 |

### 2.3 模块边界检查

- [x] 每个模块职责单一
- [x] 模块间无循环依赖
- [x] 依赖方向正确：StateMachine → 其他模块

---

## 3. 状态机设计

### 3.1 状态定义

```
┌─────────────────────────────────────────────────────────────────┐
│                         状态转换图                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────┐                                                    │
│  │  INIT   │ ─────────────────────────────────────┐             │
│  └────┬────┘                                      │             │
│       │ gate_check()                              │             │
│       ↓                                           ↓             │
│  ┌─────────┐    失败                         ┌─────────┐        │
│  │  GATE   │ ───────────────────────────────→│ FAILED  │        │
│  └────┬────┘                                 └─────────┘        │
│       │ 通过                                      ↑             │
│       ↓                                           │             │
│  ┌─────────┐    失败（重试<3）  ┌─────────┐      │             │
│  │RUN_PLAN │ ←─────────────────│ FIXING  │      │             │
│  └────┬────┘                   └────┬────┘      │             │
│       │ 完成                        ↑           │             │
│       ↓                             │ 分析+修复  │             │
│  ┌─────────┐    失败               │            │             │
│  │ CHECK   │ ──────────────────────┘            │             │
│  └────┬────┘                                    │             │
│       │ 通过                                    │             │
│       ↓                                         │             │
│  ┌─────────┐    发现问题    ┌─────────┐        │             │
│  │ REVIEW  │ ──────────────→│REVIEW_FIX│───────┘             │
│  └────┬────┘               └─────────┘  重试>=3              │
│       │ 通过                                                   │
│       ↓                                                        │
│  ┌─────────┐                                                   │
│  │ SUCCESS │                                                   │
│  └─────────┘                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 状态枚举

| 状态 | 值 | 说明 | 可转换到 |
|------|---|------|---------|
| `INIT` | 0 | 初始状态 | GATE |
| `GATE` | 1 | 门控检查中 | RUN_PLAN, FAILED |
| `RUN_PLAN` | 2 | 执行 /run-plan | CHECK, FAILED |
| `CHECK` | 3 | 执行 /check | REVIEW, FIXING, FAILED |
| `FIXING` | 4 | 自动修复中（check 失败） | CHECK, FAILED |
| `REVIEW` | 5 | 执行 /gemini-review | SUCCESS, REVIEW_FIX, FAILED |
| `REVIEW_FIX` | 6 | 自动修复中（review 问题） | CHECK, FAILED |
| `SUCCESS` | 7 | 全部通过，完成 | - |
| `FAILED` | 8 | 失败（门控/超过重试次数） | - |

### 3.3 状态转换规则

```python
TRANSITIONS = {
    "INIT": ["GATE"],
    "GATE": ["RUN_PLAN", "FAILED"],
    "RUN_PLAN": ["CHECK", "FAILED"],
    "CHECK": ["REVIEW", "FIXING", "FAILED"],
    "FIXING": ["CHECK", "FAILED"],  # 修复后重新 check
    "REVIEW": ["SUCCESS", "REVIEW_FIX", "FAILED"],
    "REVIEW_FIX": ["CHECK", "FAILED"],  # 修复后从 check 重新开始
    "SUCCESS": [],
    "FAILED": [],
}
```

---

## 4. 接口设计

### 4.1 Skill 接口（用户调用）

```markdown
/dev-loop [plan_doc_path]

参数：
- plan_doc_path（可选）：plan 文档路径，默认自动扫描 docs/开发文档/plan_*.md

返回：
- 成功：完成报告（执行统计、重试次数）
- 失败：失败报告（未解决问题列表、人工介入提示）
```

### 4.2 内部模块接口

#### Gate（门控）

```python
def check_gate() -> GateResult:
    """
    检查前置条件

    Returns:
        GateResult:
            - passed: bool
            - plan_doc: str | None  # plan 文档路径
            - gemini_available: bool  # gemini CLI 是否可用
            - error: str | None  # 失败原因
    """
```

#### StateMachine（状态机）

```python
def run(plan_doc: str) -> ExecutionResult:
    """
    执行完整的 dev-loop 流程

    Args:
        plan_doc: plan 文档路径

    Returns:
        ExecutionResult:
            - success: bool
            - state: State  # 最终状态
            - retry_count: int  # 重试次数
            - duration: float  # 耗时（秒）
            - errors: list[str]  # 未解决的错误
    """

def get_state() -> State:
    """获取当前状态"""

def transition(new_state: State) -> bool:
    """
    状态转换

    Returns:
        是否转换成功（遵循 TRANSITIONS 规则）
    """
```

#### Executor（执行器）

```python
def execute_skill(skill_name: str, args: str = "") -> SkillResult:
    """
    执行外部 Skill

    Args:
        skill_name: "run-plan" | "check" | "gemini-review"
        args: Skill 参数

    Returns:
        SkillResult:
            - success: bool
            - output: str  # Skill 输出
            - errors: list[str]  # 错误列表（如果失败）
    """
```

#### Fixer（修复器）

```python
def analyze_and_fix(errors: list[str], error_type: ErrorType) -> FixResult:
    """
    分析错误并尝试修复

    Args:
        errors: 错误列表
        error_type: L1_LINT | L2_TYPE | L3_TEST | L4_REVIEW

    Returns:
        FixResult:
            - success: bool
            - fixed_count: int  # 修复的错误数
            - remaining_errors: list[str]  # 未修复的错误
            - actions: list[str]  # 执行的修复动作
    """
```

#### Checkpoint（检查点）

```python
def save(state: CheckpointState) -> bool:
    """
    保存检查点到 docs/.checkpoint/dev_loop.json

    Args:
        state: CheckpointState
            - current_state: State
            - retry_count: int
            - plan_doc: str
            - last_errors: list[str]
            - timestamp: str
    """

def load() -> CheckpointState | None:
    """
    加载检查点（如果存在）

    Returns:
        CheckpointState 或 None（无检查点）
    """

def clear() -> bool:
    """清除检查点（执行完成后）"""
```

---

## 5. 数据模型

### 5.1 检查点文件格式

**路径**：`docs/.checkpoint/dev_loop.json`

```json
{
  "version": 1,
  "current_state": "CHECK",
  "retry_count": 1,
  "plan_doc": "docs/开发文档/plan_用户认证.md",
  "gemini_available": true,
  "last_errors": [
    "ruff: E501 line too long (120 > 88)",
    "mypy: Missing return type annotation"
  ],
  "fix_history": [
    {
      "attempt": 1,
      "error_type": "L1_LINT",
      "fixed_count": 3,
      "remaining_count": 2,
      "actions": ["ruff --fix backend/"]
    }
  ],
  "started_at": "2026-02-04T15:30:00Z",
  "updated_at": "2026-02-04T15:35:00Z"
}
```

### 5.2 错误类型枚举

| 类型 | 值 | 说明 | 修复策略 |
|------|---|------|---------|
| `L1_LINT` | 1 | lint/格式错误 | `ruff --fix` / `eslint --fix` |
| `L2_TYPE` | 2 | 类型错误 | LLM 分析 + 添加注解 |
| `L3_TEST` | 3 | 测试失败 | LLM 分析 + 修复代码 |
| `L4_REVIEW` | 4 | gemini-review 问题 | LLM 根据评审意见修复 |

### 5.3 执行结果格式

```json
{
  "success": true,
  "final_state": "SUCCESS",
  "retry_count": 1,
  "duration_seconds": 180,
  "phases": {
    "gate": {"passed": true, "duration": 2},
    "run_plan": {"passed": true, "duration": 60},
    "check": {"passed": true, "attempts": 2, "duration": 45},
    "review": {"passed": true, "duration": 30}
  },
  "fix_summary": {
    "total_errors": 5,
    "auto_fixed": 4,
    "manual_required": 1
  },
  "errors": []
}
```

---

## 6. 执行流程详细设计

### 6.1 主流程

```
/dev-loop 启动
    │
    ├─ 1. 加载检查点（如果存在）
    │      ├─ 有检查点 → 从上次状态恢复
    │      └─ 无检查点 → 初始化状态
    │
    ├─ 2. 门控检查
    │      ├─ plan 文档存在？
    │      │    ├─ 是 → 继续
    │      │    └─ 否 → FAILED（提示执行 /plan）
    │      └─ gemini CLI 可用？
    │           ├─ 是 → 正常流程
    │           └─ 否 → 降级模式（跳过 gemini-review）
    │
    ├─ 3. 执行 /run-plan
    │      └─ 保存检查点（state=RUN_PLAN）
    │
    ├─ 4. 执行 /check
    │      ├─ 通过 → 继续
    │      └─ 失败 → 进入修复循环
    │           ├─ retry_count < 3
    │           │    ├─ 分析错误类型
    │           │    ├─ 执行自动修复
    │           │    ├─ 保存检查点
    │           │    └─ 重新执行 /check
    │           └─ retry_count >= 3 → FAILED
    │
    ├─ 5. 执行 /gemini-review（如果可用）
    │      ├─ 通过（无严重问题）→ SUCCESS
    │      └─ 发现问题 → 进入修复循环
    │           ├─ retry_count < 3
    │           │    ├─ 根据评审意见修复
    │           │    ├─ 保存检查点
    │           │    └─ 重新执行 /check → /gemini-review
    │           └─ retry_count >= 3 → FAILED
    │
    └─ 6. 输出报告
           ├─ SUCCESS → 完成报告 + 清除检查点
           └─ FAILED → 失败报告 + 保留检查点
```

### 6.2 自动修复流程

```
检测到失败
    │
    ├─ 1. 错误分类
    │      ├─ 包含 "ruff" / "eslint" / "lint" → L1_LINT
    │      ├─ 包含 "mypy" / "type" / "annotation" → L2_TYPE
    │      ├─ 包含 "pytest" / "test" / "assert" → L3_TEST
    │      └─ 来自 gemini-review → L4_REVIEW
    │
    ├─ 2. 按类型修复
    │      ├─ L1_LINT
    │      │    └─ 执行：ruff check --fix . && ruff format .
    │      │
    │      ├─ L2_TYPE
    │      │    └─ LLM 分析错误信息，生成类型注解补丁
    │      │
    │      ├─ L3_TEST
    │      │    └─ LLM 分析测试失败原因，修复代码或测试
    │      │
    │      └─ L4_REVIEW
    │           └─ LLM 逐条分析评审意见，生成修复补丁
    │
    ├─ 3. 应用修复
    │      └─ 使用 Edit 工具应用补丁
    │
    └─ 4. 记录修复历史
           └─ 更新检查点 fix_history
```

---

## 7. AC 覆盖检查

| AC-ID | 设计支撑 |
|-------|---------|
| AC-1 | 状态机：INIT → GATE → RUN_PLAN → CHECK → REVIEW → SUCCESS |
| AC-2 | 状态转换：RUN_PLAN → CHECK（自动） |
| AC-3 | 状态转换：CHECK → REVIEW（自动） |
| AC-4 | 状态：SUCCESS，输出执行结果 JSON |
| AC-5 | 状态：FIXING，Fixer 模块自动修复 |
| AC-6 | 状态：REVIEW_FIX，根据评审意见修复 |
| AC-7 | 状态转换：FIXING/REVIEW_FIX → CHECK → REVIEW → SUCCESS |
| AC-8 | StateMachine.retry_count 累计 |
| AC-9 | 状态转换规则：retry_count >= 3 → FAILED |
| AC-10 | Gate 模块：plan 文档不存在 → FAILED |
| AC-11 | Gate 模块：gemini_available=false → 降级模式 |
| AC-12 | Checkpoint 模块：save() 在每次状态变更时调用 |

---

## 8. 设计约束

### 8.1 性能约束

- 单次 /check 执行：< 5 分钟
- 单次 /gemini-review 执行：< 3 分钟
- 整体 dev-loop（无重试）：< 15 分钟
- 整体 dev-loop（3 次重试）：< 45 分钟

### 8.2 安全约束

- 自动修复只能修改项目代码，不能修改系统文件
- gemini CLI 使用 `--yolo` 模式仅限只读操作

### 8.3 兼容性约束

- 必须兼容现有 /run-plan、/check、/gemini-review 的接口
- 检查点格式版本化，支持未来升级

---

## 9. 文件结构

```
~/.claude/skills/
└── 开发循环_dev-loop/
    ├── SKILL.md           # Skill 定义文件（主入口）
    └── prompts/
        └── fixer.md       # 修复器 prompt 模板（可选）
```

---

## 10. 设计检查清单

### 模块设计
- [x] 职责单一，边界清晰
- [x] 无循环依赖
- [x] 依赖方向正确

### 状态机设计
- [x] 状态定义完整
- [x] 转换规则明确
- [x] 终止条件清晰（SUCCESS/FAILED）

### 接口设计
- [x] 参数类型明确
- [x] 返回值结构化
- [x] 错误处理完整

### 数据模型
- [x] 检查点格式版本化
- [x] 错误类型枚举完整
- [x] 执行结果格式标准化

### AC 覆盖
- [x] 所有 12 条 AC 都有设计支撑

---

下一步：执行 `/plan`（写计划）
