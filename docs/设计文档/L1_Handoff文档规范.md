<!-- L1 模块规格 - 按需加载 -->
<!-- 来源：设计_人机协作模式重建.md 行 1979-2261 -->
<!-- 生成日期：2026-02-21 -->

# L1: Handoff 文档规范与 /clarify 升级

**本模块依赖**：无（Handoff 是基础数据格式规范）
**本模块被依赖**：L1_SubAgent质量设计.md（所有 SubAgent 按此格式输出）、L1_pipeline编排器.md（编排器验证 Handoff 结构）

---

## 1. Handoff 文档设计原则

- **自包含**：每个 Handoff 文档包含下一步执行所需的全部信息
- **结构化**：固定格式，便于后续 SubAgent 解析
- **可追溯**：保留在 `docs/pipeline/` 目录，全流程可回溯

---

## 2. Handoff 通用格式

```markdown
# Handoff: [步骤名]

**功能名**: [feature_name]
**执行时间**: [timestamp]
**执行结果**: PASS / FAIL / BLOCKED

---

## 输入分析（我看到了什么）
[读取了哪些文件、扫描了什么、发现了什么关键信息]

## 决策及理由（我决定做什么）
[为什么选择方案 A 而非方案 B、关键取舍的理由]

## 核心产出（我产出了什么）
[本步骤的主要输出内容]

## 交接项
[按原则 4 定义的固定传递项，各步骤内容不同]

## 修改的文件
- file1.py: [改动描述]
- file2.ts: [改动描述]
```

**核心三章节（pipeline.sh 强制校验）**：
1. **输入分析** — 不只列出读了什么文件，更要说明理解到了什么、推导出了什么方向
2. **决策** — 不只给出结论，更要说明为什么选择此方案
3. **产出** — 本步骤的具体输出

缺少任一章节 -> pipeline.sh `exit 1` 强阻断。

---

## 3. 各步骤交接项清单

| 步骤 | 向下游传递的固定项 |
|------|------------------|
| Design（额外输出） | Key_Decisions.md — 关键决策摘要，供 HUMAN_CHECKPOINT 快速审批（详见 L1_SubAgent质量设计 Designer 章节） |
| Design -> Plan（评审） | 评审反馈文件路径（review_design_N.md） |
| Design -> Plan | 接口清单、模块依赖图、技术风险点、设计约束 |
| Plan -> Implement（评审） | 评审反馈文件路径（review_plan_N.md） |
| Plan -> Implement | 任务执行顺序、文件改动清单、每任务 AC、测试策略 |
| Implement -> Check | commit 列表（含 hash）、测试运行结果摘要、已知遗留问题、BLOCKED 任务 |
| Check -> QA | QA 不直接读取 Check 输出（保证独立性） |
| QA -> Fix | FAIL 项清单（期望行为 + 实际行为 + 复现命令） |
| Fix -> Check | 修复内容摘要、回归测试清单、修复前后测试 diff |

---

## 4. SubAgent 中的文件引用方式

SubAgent 通过 prompt 传入具体文件路径（含 feature 命名空间），执行时用 Read 工具读取：

**自动模式**（pipeline.sh 注入 prompt）：
```
"请读取 docs/pipeline/用户管理/handoff_design.md 和 docs/pipeline/用户管理/handoff_clarify.md，
然后基于设计文档和需求文档编写开发计划，输出到 docs/pipeline/用户管理/handoff_plan.md"
```

**手动模式**（Skill 中 Task 工具调用）：
Skill 负责拼接当前 feature 路径，传给 SubAgent。

不使用管道输入，避免 prompt 过大浪费 token。

---

## 5. /clarify 升级方向

### 5.1 当前三个核心缺陷

1. **Slot Filling 无法暴露隐含假设**：只能收集用户已意识到的信息——用户没说出来的假设（"当然是这样的，这还用说？"）永远收集不到
2. **抽象 AC 无法验证理解对齐**：双方都觉得理解一致但各自想的可能完全不同。缺乏具体的验证手段
3. **苏格拉底被误定义为"质疑方向"**：设计方向偏向质疑需求的必要性/可行性，偏离了核心目标——确保双方对"做什么"的理解完全一致

### 5.2 升级要点

| 维度 | 当前 | 升级后 |
|------|------|--------|
| 苏格拉底角色 | 质疑方向 | 暴露隐含假设（对齐理解） |
| 执行方式 | 两阶段分离 | 逐点循环（提问 -> 示例 -> 确认） |
| 验证手段 | 无 | Example Mapping（正例 + 反例） |
| 输出格式 | Given/When/Then | Rules + Examples |
| 质疑方向 | 独立阶段 | 自然产物（证据驱动的追问） |
| 后续触发 | 无 | 完成后主动提示是否启动自动流程 |

### 5.3 第零步：先理解背景再提问

clarify 在提出任何问题前，必须先静默完成背景理解：

1. 项目全局（CLAUDE.md + README.md）-> 技术栈、架构模式
2. 相关代码逻辑（限最近修改的 5-10 个关键文件）
3. 相关规范约束
4. 相关历史（已有设计/需求文档）

内部梳理：已知信息 | 未知信息 | 约束条件
复杂度从"未知信息数量"自然得出，不靠机械打分表。

**第零步约束**（防止静默过长）：
- 时间限制：最多 30 秒
- 范围限制：只读上述文件，不全量扫描
- 用户反馈：预计超 10 秒先输出一句提示
- 止损原则：只理解与本次需求相关的上下文

### 5.4 方法论：苏格拉底提问 + Example Mapping

**理论依据**：

- **苏格拉底六类问题**（R.W. Paul）适配为需求澄清的五类提问
- **Example Mapping**（Cucumber 团队实践）：需求缺陷从 7-8 个降至 0-1 个
- 每轮只问 1-2 个问题（LLMREI 研究验证：一次问太多，用户回答质量下降）

**苏格拉底五类提问**：

| 问题类型 | 目的 | 示例 |
|---------|------|------|
| 澄清类 | 消除歧义词 | "你说的'通知'是系统推送还是站内消息？" |
| 假设探测 | 暴露隐含假设 | "你假设用户都在线，如果离线呢？" |
| 后果推演 | 发现边界条件 | "如果并发量增长 10 倍会怎样？" |
| 示例验证 | 用具体场景验证理解 | "比如 A 评论了 B 的文章，B 应该看到什么？" |
| 反例构造 | 用反例暴露遗漏 | "如果 B 已删除文章，通知还发吗？" |

**执行流程**：

```
用户输入需求
    |
第零步：理解背景（静默，<= 30 秒）
    |
第一步：目标锚定
    "这个功能要解决什么问题？"
    "谁在用？什么场景下用？"
    |
第二步：逐点深挖循环
    每个关键点：
    1. 苏格拉底提问（暴露盲区）
    2. 生成具体示例（验证理解）
    3. 用户确认或修正
    4. 进入下一个点
    每轮 1-2 个问题
    |
第三步：结构化复述
    "我的理解是：[Rules+Examples]"
    "不确定项：[待确认问题]"
    |
用户确认 -> 输出 handoff
```

**质疑方向的定位**：不是独立阶段，而是逐点深挖的自然产物。当发现核心场景很少或实现复杂度远超收益时，自然引出基于证据的追问。

不做质疑的场景：Bug 修复、明确的技术债务清理、用户已深思熟虑的功能。

### 5.5 Few-shot 示例

```
好的澄清对话：
用户："我要做一个通知功能。"
Claude："让我用一个具体场景确认——
  当用户 A 评论了用户 B 的文章时，
  用户 B 在 5 秒内看到一个红点提示，
  点击后看到评论内容。
  这是你要的效果吗？"
用户："不是，不需要红点，只要打开通知页面能看到就行。"
Claude："如果用户 B 一直不打开通知页面，通知会一直累积吗？有没有保留期限？"
-> 一个具体示例暴露了"实时推送"和"红点提示"两个隐含假设

坏的澄清：
"你确定需要通知吗？用户真的会用吗？"（空泛质疑）
"通知类型有哪些？延迟要求？"（纯 Slot Filling，理解仍可能不一致）
```

> 详见 L2 原文 行 2186-2217（完整 Few-shot 对比）

### 5.6 输出格式

`/clarify` 输出 `docs/pipeline/{feature_name}/handoff_clarify.md`：

```markdown
# Handoff: Clarify

**功能名**: [feature_name]
**确认时间**: [timestamp]

---

## 需求概述
[一句话描述功能目标和核心场景]

## 功能规则与示例

### 规则 1: [规则名称]
[一句话描述规则]

- [正例：输入/条件 -> 期望结果]
- [正例：另一个场景 -> 期望结果]
- [反例：不应该发生的场景 -> 期望处理方式]
- [待确认项：无法确定的场景]（待确认）

### 规则 2: [规则名称]
...

## 排除项
- [明确不做的事情]

## 技术约束
- [项目级约束，如技术栈、兼容性要求]
```

**粒度标准**：clarify 确保方向和范围无歧义，技术实现细节由 design 阶段补充。Rules + Examples 格式让 design 阶段可以直接从每条规则推导接口和数据模型。

### 5.7 输出前自检

1. 对话中提到但未写入 Handoff 的信息？
2. 每条规则至少 1 个正例和 1 个反例？
3. 排除项明确列出？
4. 是否存在用户未意识到的隐含假设？（标注为待确认项）
