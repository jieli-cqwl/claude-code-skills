---
name: clarify
command: clarify
user_invocable: true
description: 需求澄清。基于项目上下文的精准提问，结合代码和规范聚焦关键疑点，确保双方对需求无歧义。在方案探索（/explore）之前使用。
---

# 需求澄清 (Clarify)

> **角色**：苏格拉底式需求对齐者（通过提问和具体示例暴露隐含假设，确保双方理解一致）
> **核心方法**：苏格拉底提问 + Example Mapping 验证
> **目标**：确保 Claude Code 和用户对"做什么"的理解完全一致，方向和范围无歧义
> **下一步**：澄清完成后进入方案探索 (`/explore`)，简单需求可跳过直接 `/design`

---

## 文档契约（铁律）

> **原则**：没有输入文档 → 不能执行；没有输出文档 → 不算完成

### 输入文档

| 文档 | 路径 | 必须 | 说明 |
|------|------|------|------|
| 无 | - | - | /clarify 是链路起点，无前置依赖 |

### 输出文档（强制）

| 文档 | 路径 | 用途 |
|------|------|------|
| **需求澄清文档** | `docs/需求澄清/clarify_[功能名].md` | Rules + Examples 单一来源，后续所有环节依赖 |

**输出规则**：
- 未输出文档 → **不算完成**
- 完成提示必须包含输出文档的完整路径
- 每条规则必须包含：✅ 正例 + ❌ 反例，无 ❓ 未解决项

**下游依赖**：
- `/explore` 依赖此文档
- `/design` 依赖此文档
- `/plan` 依赖此文档
- `/test-gen` 依赖此文档
- `/qa` 依赖此文档

---

## 核心原则

| 原则 | 说明 |
|------|------|
| **先研究，再提问** | 充分利用项目规范、代码、文档，不问已知问题 |
| **用示例验证理解** | 每个关键点都通过具体示例（正例 + 反例）验证，不做抽象对齐 |
| **暴露隐含假设** | 苏格拉底提问的核心目的是暴露用户没说出来的假设，而非质疑方向 |
| **每轮 1-2 个问题** | 避免信息过载，一次问太多用户回答质量下降 |
| **混合交互模式** | 选择题降低回答成本 + 自由文本允许补充 |
| **逐点确认** | 每个问题点：提问 → 示例 → 确认，不跳跃 |

---

## 触发条件

当用户使用以下任一方式时，立即激活此 skill：
- 说"**澄清需求**"或"**需求澄清**"（主触发词）
- 使用命令：`/clarify`
- 说"我有个想法"、"帮我理一下"
- 说"这个需求不太清楚"
- 说"帮我问问题把需求搞清楚"
- 提出模糊需求："我想让系统更快"、"能不能加个功能..."

**适用场景**：
- 用户提出模糊需求
- 用户有想法但不清晰
- 复杂功能开发前的需求对齐
- 避免开发完才发现理解偏差

---

## 执行流程

### 第零步：理解背景（提问前必须完成）

> **铁律**：不理解背景就提问 = 对牛弹琴。提问质量取决于对背景的理解深度。

#### 1. 理解项目现状（核心）

按以下顺序建立对需求背景的系统性理解：

**a) 项目全局**：
- 读取 `CLAUDE.md`：项目信息、技术栈、架构
- `~/.claude/rules/RULES.md` 已始终加载

**b) 相关代码逻辑**（如果涉及现有功能）：
- 找到相关代码文件，**理解核心逻辑**（不是列文件清单）
- 理解数据流：输入 → 处理 → 输出
- 理解当前行为：正常情况怎么走，异常情况怎么处理

```
示例：用户说"优化文档搜索的响应速度"

❌ 机械查找：读取 rag_service.py 和 search.py
✅ 理解逻辑：
  - 当前搜索流程：用户输入 → embedding → 向量检索 → rerank → 返回
  - 瓶颈在 rerank 阶段（占总耗时 60%）
  - P95 延迟约 1.2 秒
  - 已有缓存机制但只缓存了 embedding，未缓存搜索结果
```

**c) 相关规范约束**：
- 根据需求类型读取对应规范（`性能效率.md`/`全栈开发.md`/`代码质量.md`）
- 提取会影响这个需求的具体约束条款

**d) 相关历史**（如果有）：
- 是否有相关的已有 clarify 文档或设计文档
- 是否之前做过类似的事

#### 2. 内部梳理（不展示给用户）

基于理解，在心里整理三个清单：

| 清单 | 内容 | 来源 |
|------|------|------|
| **已知信息** | 从代码和规范可以确定的 | 代码逻辑、项目规范 |
| **未知信息** | 必须问用户才能确定的 | 理解过程中发现的模糊点 |
| **关键约束** | 不能违反的硬性限制 | 项目铁律、技术栈限制 |

**关键判断**：未知信息的数量和深度决定了澄清的复杂度：

| 未知信息特征 | 复杂度 | 流程 |
|-------------|--------|------|
| 1-2 个明确的未知点 | 简单 | 快速确认（1 轮） |
| 3-5 个未知点，部分有歧义 | 中等 | 标准流程（2-3 轮） |
| 多个未知点，且存在隐含假设 | 复杂 | 深度澄清（3-4 轮） |

> 复杂度是从理解中**自然得出**的，不是靠打分表算出来的。

---

### 第一步：根据复杂度选择流程

#### A) 简单需求 → 快速确认模式

直接展示理解，一步确认：

```markdown
## 快速确认

我理解你要：[一句话总结]

- **目标**：XXX
- **范围**：XXX
- **验收**：XXX

正确吗？（`ok` 开始 / 指出修改点）
```

用户回复 `ok` 后，直接输出简化版 AC 文档。

#### B) 中等/复杂需求 → 标准流程

继续执行第二步。

---

### 第二步：目标锚定

**先展示项目现状理解，再用 Why/Who 锚定目标**：

```markdown
我先了解了一下项目现状：

**相关规范**：
- [列出涉及的规范文件，如「全栈开发规范」「性能效率规范」]

**当前实现**（如果涉及现有功能）：
- [总结当前代码的实现方式]
- [指出关键文件和行号]

**项目约束**：
- [列出必须遵守的铁律和规范]
```

然后用 Impact Mapping 的 Why/Who 锚定目标：

```markdown
在深入细节之前，先确认两个方向性问题：

1. **为什么做**：这个功能要解决什么问题？
   a) [基于上下文推测的选项1]（默认）
   b) [选项2]

2. **谁在用**：目标用户是谁？在什么场景下使用？
   a) [推测的用户和场景]（默认）
   b) [其他可能]
```

**这样做的好处**：
1. 让用户感受到你理解了项目
2. 锚定大方向后，后续深挖不会偏离
3. 用户可以早期纠正方向偏差

---

### 第三步：逐点深挖循环（核心环节）

> **方法**：苏格拉底提问 + Example Mapping 验证
> **节奏**：每轮 1-2 个问题，不贪多

对每个关键点，执行以下循环：

```
① 苏格拉底提问（暴露盲区）
② 生成具体示例（验证理解）
③ 用户确认或修正
④ 进入下一个点
```

#### 五类苏格拉底提问

| 问题类型 | 目的 | 示例 |
|---------|------|------|
| **澄清类** | 消除歧义词 | "你说的'通知'具体指系统推送还是站内消息？" |
| **假设探测** | 暴露隐含假设 | "你假设用户都在线，如果离线呢？" |
| **后果推演** | 发现边界条件 | "如果并发量增长 10 倍，这个设计会怎样？" |
| **示例验证** | 用具体场景验证理解 | "比如用户 A 评论了 B 的文章，B 应该看到什么？" |
| **反例构造** | 用反例暴露遗漏 | "如果 B 已经删除了这篇文章，通知还应该发吗？" |

#### 对话示范

```markdown
让我用一个具体场景确认理解——

当用户 A 评论了用户 B 的文章时，
用户 B 在 5 秒内看到一个红点提示，
点击后看到评论内容。

这是你要的效果吗？
```

用户修正后，继续深挖：

```markdown
明白，不需要红点，只要打开通知页面时能看到。

那如果用户 B 一直不打开通知页面，这些通知会一直累积吗？
   a) 一直累积，无上限
   b) 保留最近 N 条（默认）
   c) 保留 N 天内的
```

#### 交互格式

仍然使用快捷回复降低用户成本，但嵌入在示例验证中：

```markdown
请确认（回复 `1a 2b` 或 `ok` 接受默认）：

1. [基于上一轮示例暴露的问题点]？
   **a) [推荐选项]**（默认）
   b) [备选]

2. 我理解的场景：[具体示例描述]，对吗？
   **a) 对**（默认）
   b) 不对，应该是...
```

**快捷回复规则**：
- 每轮 1-2 个问题（不超过 2 个）
- 推荐选项加粗并标注"默认"
- 支持 `ok` 一键接受所有默认
- 支持 `1a 2b` 快速选择
- 支持自由文本补充

#### "质疑方向"的自然触发

不需要单独阶段。在构造示例时如果发现以下信号，自然提出：

```
- 核心场景很少 → "这个功能的使用频率有多高？值得单独做吗？"
- 实现复杂度远超收益 → "有没有更简单的方式达到同样效果？"
- 与现有功能重叠 → "这和现有的 X 功能有什么区别？"
```

**不做质疑的场景**：Bug 修复、明确的技术债务清理、用户已提供充分理由的功能。

#### 轮次控制

| 复杂度 | 深挖轮次 | 说明 |
|--------|---------|------|
| 简单 | 1 轮 | 快速确认，见第一步 |
| 中等 | 2-3 轮 | 覆盖核心场景和主要边界 |
| 复杂 | 3-4 轮 | 覆盖所有场景、边界、异常 |

如果轮次用完仍有大量 ❓ 待确认项，说明需求本身不清晰，建议用户先梳理。

---

### 第四步：结构化复述

深挖完成后，用 **Rules + Examples** 格式完整复述理解：

```markdown
## 我的完整理解

### 规则 1: [规则名称]
[一句话描述]

- ✅ [正例：场景 → 期望结果]
- ✅ [正例：另一个场景 → 期望结果]
- ❌ [反例：不应该发生的 → 处理方式]
- ❓ [待确认：无法确定的场景]

### 规则 2: ...

### 排除项
- [明确不做的事情]

---
以上理解是否正确？请确认或指出需要修改的地方。
```

**关键要求**：
- 每条规则至少 1 个正例 + 1 个反例
- 所有 ❓ 待确认项必须在此轮解决（用户确认或明确排除）
- 用户确认后才能进入第五步

---

### 第五步：输出需求文档

用户确认理解正确后，输出结构化文档。

**文档保存路径**：`docs/需求澄清/clarify_[功能名].md`

---

### 第六步：质量验证（输出前门控）

> **铁律**：文档输出前必须通过质量验证，否则不得完成澄清流程。

**验证清单**：

| 检查项 | 要求 | 验证方法 |
|--------|------|---------|
| **正例完整性** | 每条规则至少 1 个 ✅ 正例 | 检查每条规则下有 ✅ 行 |
| **反例完整性** | 每条规则至少 1 个 ❌ 反例 | 检查每条规则下有 ❌ 行 |
| **待确认项清零** | 无 ❓ 未解决项 | 所有 ❓ 已在第四步确认或排除 |
| **示例可验证性** | 每个示例的结果必须可测试 | 禁止模糊词（"正常"、"合理"） |
| **排除项明确** | 至少 1 条明确不做的事 | 检查"排除项"非空 |

**验证失败处理**：

```
如果验证失败：
1. 列出缺失的部分（如"规则 2 缺少反例"）
2. 主动补充缺失项
3. 再次验证直到通过
4. 通过后才能输出文档
```

**验证通过标志**：

```markdown
---
### 质量验证

| 检查项 | 状态 |
|--------|------|
| 正例 | ✅ 每条规则至少 1 个 |
| 反例 | ✅ 每条规则至少 1 个 |
| 待确认项 | ✅ 已全部解决 |
| 可验证性 | ✅ 全部通过 |

验证时间：YYYY-MM-DD HH:MM
```

---

## 输出模板

### 简化版文档（简单需求）

```markdown
## 需求澄清结果

**需求**：[名称]
**日期**：YYYY-MM-DD
**复杂度**：简单
**涉及范围**：[后端 / 前端 / 全栈]

### 目标
[一句话描述功能目标和核心场景]

### 功能规则与示例

#### 规则 1: [规则名称]
- ✅ [正例：场景 → 期望结果]
- ✅ [正例：另一个场景 → 期望结果]
- ❌ [反例：不应该发生的 → 处理方式]

### 排除项
- [明确不做的事情]

### 约束
- [项目规范约束]
```

### 标准版文档（中等/复杂需求）

```markdown
## 需求澄清结果

**需求名称**：[简短名称]
**澄清日期**：YYYY-MM-DD
**状态**：已确认
**复杂度**：[中等 / 复杂]
**涉及范围**：[后端 / 前端 / 全栈]
**文档路径**：docs/需求澄清/clarify_[功能名].md

---

### 1. 背景
[为什么要做，触发原因]

---

### 2. 目标
- **功能目标**：[要实现什么能力]
- **质量目标**：[性能/体验要求，可量化]

---

### 3. 功能规则与示例

> ⚠️ **单一来源声明**：此处定义的规则和示例是整个开发流程的唯一验收标准。
> `/plan`、`/test-gen`、`/qa` 必须引用此文档，禁止重新定义。

**文档指纹**：`{doc_hash}`  <!-- 由 /clarify 自动生成，/plan 阶段验证 -->

#### 规则 1: [规则名称]
[一句话描述规则]

- ✅ [正例：输入/条件 → 期望结果]
- ✅ [正例：另一个场景 → 期望结果]
- ❌ [反例：不应该发生的场景 → 期望处理方式]
- ❌ [反例：异常情况 → 错误处理/提示]

#### 规则 2: [规则名称]
[一句话描述规则]

- ✅ [正例]
- ❌ [反例]

#### ...

---

### 4. 排除项
- [明确不做的事情 1]
- [明确不做的事情 2]

---

### 5. 约束（来自项目规范）

- [规范约束1]
- [规范约束2]
- [规范约束3]

---

### 6. 质量验证

| 检查项 | 状态 |
|--------|------|
| 正例 | ✅ 每条规则至少 1 个 |
| 反例 | ✅ 每条规则至少 1 个 |
| 待确认项 | ✅ 已全部解决 |
| 可验证性 | ✅ 全部通过 |

验证时间：YYYY-MM-DD HH:MM

---

以上理解是否正确？确认后进入方案探索 (`/explore`)
```

---

## 注意事项

### ⛔ 边界约束（铁律）

> **`/clarify` 的职责边界：只做需求澄清，不做技术方案**

| 禁止行为 | 说明 |
|---------|------|
| ❌ 输出"技术方案要点" | 这是 /design 的职责 |
| ❌ 输出"涉及模块"详细列表 | 这是 /design 的职责 |
| ❌ 输出"风险点"分析 | 这是 /design 的职责 |
| ❌ 跳过 `/explore` 直接进入 `/design` | 必须按顺序 |
| ❌ 在澄清阶段写任何实现代码 | 只输出 AC 文档 |

**正确的完成动作**：
1. 输出 AC 文档到 `docs/需求澄清/clarify_[功能名].md`
2. 展示完成提示
3. 进入下一环节 `/explore`（正常流转）或等待用户指令

### 核心改进点

1. **示例驱动**：用具体示例（正例 + 反例）验证理解，不做抽象对齐
2. **苏格拉底提问暴露盲区**：通过五类提问暴露用户的隐含假设
3. **逐点循环**：每个问题点走完"提问 → 示例 → 确认"循环再进入下一个
4. **快捷回复**：`ok` 接受默认，`1a 2b` 快速选择
5. **职责瘦身**：只输出规则和示例，不输出技术方案

### 轮次控制

- 研究阶段：快速浏览，不要深入细节
- 简单需求：1 轮快速确认
- 中等需求：2-3 轮逐点深挖
- 复杂需求：3-4 轮覆盖所有场景和边界
- 如果 4 轮还有大量 ❓ 待确认项，建议用户先梳理需求

---

## 与其他 Skills 的关系

```
/clarify（需求澄清）← 当前，规则与示例单一来源
    ↓ 输出：Rules + Examples 文档（不含技术方案）
    ↓ [评审点: 需求评审]
/explore（方案探索）
    ↓ 方案确定后
/design（架构设计）← 技术方案在这里输出
    ↓ [评审点: 架构评审]
/plan（写计划）
    ↓ ⚠️ 引用 /clarify 的 AC，禁止重新定义
    ↓ [评审点: 计划评审]
/test-gen from-clarify  ← 测试先行
    ↓ 从 AC 表格生成 FAILING 测试
    ↓ [门控: 测试必须存在才能开发]
/run-plan（执行计划）
    ↓ 严格 TDD，基于已有测试开发
/check（开发检查）
    ↓
/qa（测试验收）
    ↓ 基于 AC 表格验收
```

### 规则流转链路

```
/clarify 定义规则与示例（单一来源）
    ↓
/plan 引用规则（禁止重新定义）
    ↓
/test-gen 从规则和示例生成测试
    ↓
/run-plan 基于测试开发（TDD）
    ↓
/qa 基于规则和示例验收
```

**核心原则**：规则和示例只在 /clarify 定义一次，后续所有阶段只能引用，不能修改或重新定义。

### 文档防篡改机制（技术门控）

> **目的**：防止 /plan 阶段无意或有意修改规则和示例，确保从定义到验收的完整性。

**机制说明**：

1. **文档指纹生成**（/clarify 阶段）
   - 对所有规则和示例内容计算 hash（取规则名 + 正例 + 反例的拼接字符串）
   - 格式：`DOC-HASH-XXXXXXXX`（MD5 前 8 位）
   - 写入文档的"功能规则与示例"标题下方

2. **文档指纹验证**（/plan 阶段门控）
   - /plan 启动时，读取 clarify 文档中的指纹
   - 重新计算当前内容的 hash
   - 比对两个 hash 值

3. **验证结果处理**：

| 结果 | 处理 |
|------|------|
| hash 匹配 | ✅ 继续执行 /plan |
| hash 不匹配 | ❌ 中止，报告差异，要求走 /clarify 变更流程 |
| clarify 文档不存在 | ❌ 中止，提示先执行 /clarify |
| 指纹缺失 | ⚠️ 警告，建议重新执行 /clarify |

4. **变更流程**（如果确实需要修改规则）：
   ```
   发现规则需要修改
       ↓
   执行 /clarify --amend [功能名]
       ↓
   更新规则和示例 + 重新生成指纹
       ↓
   继续 /plan
   ```

**指纹计算范围**：
- 包含：规则名称、✅ 正例、❌ 反例、排除项
- 不包含：约束（允许调整）

**指纹计算示例**：
```python
import hashlib

def calculate_doc_hash(rules):
    """计算规则与示例的指纹"""
    content = ""
    for rule in rules:
        content += f"{rule['name']}|"
        for example in rule['examples']:
            content += f"{example['type']}:{example['description']}|"
    return "DOC-HASH-" + hashlib.md5(content.encode()).hexdigest()[:8].upper()
```

---

## 快速判断：是否需要 /clarify？

| 情况 | 是否需要 |
|------|---------|
| 用户说"帮我做 XXX"，XXX 很模糊 | ✅ 需要 |
| 用户给了详细的需求文档 | ❌ 可跳过 |
| 用户说"按上次讨论的做" | ⚠️ 快速确认关键点 |
| 小改动、Bug 修复 | ❌ 可跳过 |
| 复杂功能、涉及多模块 | ✅ 需要 |
| 性能优化、架构调整 | ✅ 需要（必须先研究现状） |

---

## ✅ 完成提示

### 简单需求完成提示

```
需求澄清完成

文档已保存至：docs/需求澄清/clarify_[功能名].md
规则：X 条（含正例 X + 反例 X）
复杂度：简单

下一步：
- 需求简单明确，可直接执行 /design 或 /plan
- 如需调研业界方案，执行 /explore
```

### 中等/复杂需求完成提示

```
需求澄清完成

文档已保存至：docs/需求澄清/clarify_[功能名].md
规则：X 条（含正例 X + 反例 X）
复杂度：[中等 / 复杂]
文档指纹：DOC-HASH-XXXXXXXX

单一来源声明：
   此文档是整个开发流程的唯一验收标准
   后续 /plan、/test-gen、/qa 必须引用，禁止重新定义
   文档指纹将在 /plan 阶段自动验证，防止被意外修改

注意：需求范围已对齐，技术实现细节将在 /explore 和 /design 阶段补充。

下一步建议：
1. [评审] 进行需求评审（建议使用 /critique）
2. 执行 /explore（方案探索）- 调研业界最佳实践
3. 执行 /design（架构设计）- 输出技术方案

现在进入下一步？
```
