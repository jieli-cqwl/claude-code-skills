---
name: clarify
command: clarify
user_invocable: true
description: 需求澄清。基于项目上下文的精准提问，结合代码和规范聚焦关键疑点，确保双方对需求无歧义。在方案探索（/explore）之前使用。
---

# 需求澄清 (Clarify)

> **角色**：上下文感知的苏格拉底式提问者
> **目标**：基于需求、现状精准澄清需求
> **下一步**：澄清完成后进入方案探索 (`/explore`)，简单需求可跳过直接 `/design`

---

## 文档契约（铁律）

> **原则**：没有输入文档 → 不能执行；没有输出文档 → 不算完成

### 输入文档

| 文档 | 路径 | 必须 | 说明 |
|------|------|------|------|
| 无 | - | - | /clarify 是链路起点，无前置依赖 |

### 输出文档（强制）

| 文档 | 路径 | 用途 |
|------|------|------|
| **AC 文档** | `docs/需求澄清/clarify_[功能名].md` | AC 单一来源，后续所有环节依赖 |

**输出规则**：
- 未输出 AC 文档 → **不算完成**
- 完成提示必须包含输出文档的完整路径
- AC 表格必须包含：正常流程 + 异常流程 + 边界情况

**下游依赖**：
- `/explore` 依赖此文档
- `/design` 依赖此文档
- `/plan` 依赖此文档
- `/test-gen` 依赖此文档
- `/qa` 依赖此文档

---

## 核心原则

| 原则 | 说明 |
|------|------|
| **先研究，再提问** | 充分利用项目规范、代码、文档 |
| **聚焦关键疑点** | 只问真正不确定的问题 |
| **结合项目约束** | 基于规范主动告知约束，不问已知 |
| **一次一个核心问题** | 避免信息过载 |
| **优先选择题** | 降低回答成本 |
| **记录共识** | 每个确认点都要记录 |

---

## 触发条件

当用户使用以下任一方式时，立即激活此 skill：
- 说"**澄清需求**"或"**需求澄清**"（主触发词）
- 使用命令：`/clarify`
- 说"我有个想法"、"帮我理一下"
- 说"这个需求不太清楚"
- 说"帮我问问题把需求搞清楚"
- 提出模糊需求："我想让系统更快"、"能不能加个功能..."

**适用场景**：
- 用户提出模糊需求
- 用户有想法但不清晰
- 复杂功能开发前的需求对齐
- 避免开发完才发现理解偏差

---

## 执行流程

### 第零步：复杂度评估 + 项目上下文研究

**在提问前，必须先评估复杂度并研究项目**：

#### 1. 复杂度判断（决定流程深度）

**量化评分表（0-10 分制）**：

| 维度 | 0-3 分（简单） | 4-6 分（中等） | 7-10 分（复杂） | 权重 |
|------|--------------|---------------|----------------|------|
| **文件影响** | 1 个文件 | 2-5 个文件 | 6+ 个文件 | 1.0 |
| **设计决策** | 无需决策 | 1-2 个决策点 | 3+ 个决策点 | 1.5 |
| **架构变更** | 无变更 | 局部调整 | 跨层/全局重构 | 2.0 |
| **需求清晰度** | 明确无歧义 | 有 1-2 处歧义 | 多处模糊或矛盾 | 1.5 |
| **数据流复杂度** | 单向/无状态 | 双向/简单状态 | 多源/复杂状态流转 | 1.0 |
| **依赖复杂度** | 无外部依赖 | 1-2 个外部服务 | 3+ 个外部服务/链式依赖 | 1.0 |
| **交互复杂度** | 单接口/无交互 | 2-3 个接口联动 | 多端协同/实时交互 | 1.0 |
| **边界条件** | 边界明确 | 部分边界需确认 | 边界模糊/大量异常场景 | 1.0 |
| **并发/一致性** | 无并发 | 简单并发/最终一致 | 强一致性/分布式事务 | 1.0 |

**评分方法**：
1. 对每个维度打分（0-10）
2. 加权计算：`总分 = Σ(维度分 × 权重) / Σ权重`
3. 结果取整到最近整数

**总分判定**：
| 加权总分 | 复杂度 | 流程 | 输出 AC 数量 |
|---------|--------|------|-------------|
| 0-3 分 | 简单 | 快速确认（1 轮） | 2-3 条 |
| 4-6 分 | 中等 | 标准流程（2 轮） | 5-8 条 |
| 7-10 分 | 复杂 | 深度澄清（3 轮） | 10+ 条 |

**评分示例**：
```
需求：优化搜索响应速度
- 文件影响：4 分（涉及 3 个文件）× 1.0 = 4
- 设计决策：5 分（缓存策略、索引策略）× 1.5 = 7.5
- 架构变更：3 分（无架构变更）× 2.0 = 6
- 需求清晰度：6 分（"快"需要量化）× 1.5 = 9
- 数据流：4 分（查询链路简单）× 1.0 = 4
- 依赖：2 分（仅 ES）× 1.0 = 2
- 交互：2 分（单接口）× 1.0 = 2
- 边界条件：5 分（空结果、超时）× 1.0 = 5
- 并发：3 分（无强一致性要求）× 1.0 = 3
加权总分 = 42.5 / 11 = 3.9 → 中等复杂度
```

#### 2. 读取项目规范

根据需求类型，读取相关规范：

| 需求类型 | 必读规范 | 关注点 |
|---------|---------|--------|
| 性能优化 | `~/.claude/reference/性能效率.md` | 缓存、复用、批量、并发策略 |
| 新功能开发 | `~/.claude/reference/全栈开发.md` | 前后端同步、API 设计 |
| 任何需求 | `~/.claude/reference/代码质量.md` | 三条铁律、零容忍行为 |
| 批量操作 | `~/.claude/reference/性能效率.md` | 批量操作、事务处理 |
| 错误处理 | `~/.claude/reference/代码质量.md` | 用户友好提示、错误处理规范 |

**必读文件**：
- `CLAUDE.md`：项目信息、技术栈、铁律
- `~/.claude/rules/RULES.md`：核心规范（始终已加载）

#### 3. 读取相关代码

如果涉及现有功能，必须先了解当前实现：

```python
# 示例：用户说"优化文档搜索"
需要读取：
- backend/app/services/rag_service.py       # 当前搜索实现
- backend/app/api/v1/endpoints/search.py    # API 接口
```

#### 4. 内部梳理（不展示给用户）

在心里整理：
- **已知信息**：从规范和代码可以推断的
- **未知信息**：必须问用户的
- **关键约束**：不能违反的规范

---

### 第一步：根据复杂度选择流程

#### A) 简单需求 → 快速确认模式

直接展示理解，一步确认：

```markdown
## 快速确认

我理解你要：[一句话总结]

- **目标**：XXX
- **范围**：XXX
- **验收**：XXX

正确吗？（`ok` 开始 / 指出修改点）
```

用户回复 `ok` 后，直接输出简化版 AC 文档。

#### B) 中等/复杂需求 → 标准流程

继续执行第二步。

---

### 第二步：总结当前状态（展示给用户）

**不要直接问问题，先展示你的理解**：

```markdown
我先了解了一下项目现状：

**相关规范**：
- [列出涉及的规范文件，如「全栈开发规范」「性能效率规范」]

**当前实现**（如果涉及现有功能）：
- [总结当前代码的实现方式]
- [指出关键文件和行号]

**项目约束**：
- [列出必须遵守的铁律和规范]
```

**这样做的好处**：
1. 让用户感受到你理解了项目
2. 用户可以纠正你的理解偏差
3. 建立信任，提高沟通效率

---

### 第三步：快捷回复式提问

**使用快捷回复格式，降低用户回复成本**：

```markdown
请确认（回复 `1a 2b` 或 `ok` 接受默认）：

1. [问题1]？
   **a) [选项1]**（默认）
   b) [选项2]

2. [问题2]？
   **a) [选项1]**（默认）
   b) [选项2]
   c) [选项3]
```

**快捷回复规则**：
- 每个问题 2-4 个选项
- 推荐选项加粗并标注"默认"
- 支持 `ok` 一键接受所有默认
- 支持 `1a 2b` 快速选择
- 支持自由文本补充

**解析优先级**（容错处理）：
1. 包含 `1a`/`2b` 等选项格式 → 按选项解析
2. 只有 `ok` → 接受所有默认
3. `1` 不带字母 → 使用该问题的默认选项
4. 无效选项（如 `1d` 但只有 a/b/c）→ 提示用户重新选择
5. 混合输入（如 `1b，另外...`）→ 选项 + 补充说明

**示例**：

```markdown
请确认（回复 `1a 2b` 或 `ok` 接受默认）：

1. 优化目标？
   **a) 响应速度**（默认）- 目标 < 500ms
   b) 准确率 - 提高搜索相关性

2. 影响范围？
   **a) 仅后端**（默认）
   b) 前后端都改
```

用户可以回复：
- `ok` → 接受所有默认（1a 2a）
- `1b` → 选择 1b，其他用默认
- `1b 2b` → 选择 1b 和 2b
- `1b，另外还需要考虑缓存` → 选择 + 补充

---

### 第四步：确认边界和约束

基于项目规范，主动列出边界：

```markdown
根据项目规范，以下是必须遵守的：

**质量要求**（来自代码质量规范）：
- 禁止降级、禁止硬编码、禁止 Mock
- 错误提示用户友好（无技术细节）

**性能要求**（来自性能效率规范）：
- 数据库操作批量化
- 避免 N+1 查询

这些约束是否会影响你的需求？
```

---

### 第五步：输出需求文档

需求澄清完成后，根据复杂度输出对应格式的文档。

**📁 文档保存路径**：`docs/需求澄清/clarify_[功能名].md`

---

### 第六步：AC 质量验证（输出前门控）

> **铁律**：AC 文档输出前必须通过质量验证，否则不得完成澄清流程。

**验证清单**：

| 检查项 | 要求 | 验证方法 |
|--------|------|---------|
| **正常流程完整性** | 至少 1 条核心正常流程 AC | 检查"正常流程"表格非空 |
| **异常流程完整性** | 至少 1 条异常处理 AC | 检查"异常流程"表格非空 |
| **边界情况完整性** | 至少 1 条边界条件 AC | 检查"边界情况"表格非空 |
| **AC 可验证性** | 每条 AC 的 Then 必须可测试 | Then 列禁止模糊词（"正常"、"合理"） |
| **AC 无冗余** | 无重复或近似 AC | 检查 AC 间无语义重叠 |

**验证失败处理**：

```
如果验证失败：
1. 列出缺失的部分（如"缺少异常流程 AC"）
2. 主动补充缺失的 AC
3. 再次验证直到通过
4. 通过后才能输出文档
```

**验证通过标志**：

在 AC 文档中增加验证戳记：

```markdown
---
### AC 质量验证

| 检查项 | 状态 |
|--------|------|
| 正常流程 | ✅ X 条 |
| 异常流程 | ✅ X 条 |
| 边界情况 | ✅ X 条 |
| 可验证性 | ✅ 全部通过 |

验证时间：YYYY-MM-DD HH:MM
```

---

## 输出模板

### 简化版 AC 文档（简单需求）

```markdown
## 需求澄清结果

**需求**：[名称]
**日期**：YYYY-MM-DD
**复杂度**：简单
**涉及范围**：[后端 / 前端 / 全栈]

### 目标
[一句话描述]

### 验收标准
| AC-ID | Given | When | Then | 优先级 | 测试方法 |
|-------|-------|------|------|--------|---------|
| AC-1 | [前置条件] | [操作] | [结果] | P0 | API 测试 |
| AC-2 | [前置条件] | [操作] | [结果] | P0 | API 测试 |
| AC-3 | [边界/异常] | [操作] | [处理方式] | P1 | 单元测试 |

### 约束
- [项目规范约束]
```

### 标准版 AC 文档（中等/复杂需求）

```markdown
## 需求澄清结果

**需求名称**：[简短名称]
**澄清日期**：YYYY-MM-DD
**状态**：已确认
**复杂度**：[中等 / 复杂]
**涉及范围**：[后端 / 前端 / 全栈]
**文档路径**：docs/需求澄清/clarify_[功能名].md

---

### 1. 背景
[为什么要做，触发原因]

---

### 2. 目标
- **功能目标**：[要实现什么能力]
- **质量目标**：[性能/体验要求，可量化]

---

### 3. 验收标准（Acceptance Criteria）

> ⚠️ **AC 单一来源声明**：此处定义的 AC 是整个开发流程的唯一验收标准。
> `/plan`、`/test-gen`、`/qa` 必须引用此 AC，禁止重新定义。

**AC 指纹**：`{ac_hash}`  <!-- 由 /clarify 自动生成，/plan 阶段验证 -->

#### 正常流程
| AC-ID | Given（前置条件） | When（操作） | Then（预期结果） | 优先级 | 测试方法 |
|-------|------------------|-------------|-----------------|--------|---------|
| AC-1 | [用户状态/数据准备] | [具体操作] | [可验证的结果] | P0 | E2E |
| AC-2 | ... | ... | ... | P0 | 集成测试 |

#### 异常流程
| AC-ID | Given | When | Then | 优先级 | 测试方法 |
|-------|-------|------|------|--------|---------|
| AC-3 | [异常前置条件] | [触发异常的操作] | [错误处理/提示] | P1 | API 测试 |

#### 边界情况
| AC-ID | Given | When | Then | 优先级 | 测试方法 |
|-------|-------|------|------|--------|---------|
| AC-4 | [边界条件] | [边界操作] | [边界处理结果] | P2 | 单元测试 |

---

### 4. AC 质量验证

| 检查项 | 状态 |
|--------|------|
| 正常流程 | ✅ X 条 |
| 异常流程 | ✅ X 条 |
| 边界情况 | ✅ X 条 |
| 可验证性 | ✅ 全部通过 |

验证时间：YYYY-MM-DD HH:MM

---

### 5. 约束（来自项目规范）

- [规范约束1]
- [规范约束2]
- [规范约束3]

---

以上理解是否正确？确认后进入方案探索 (`/explore`)
```

---

## 注意事项

### ⛔ 边界约束（铁律）

> **`/clarify` 的职责边界：只做需求澄清，不做技术方案**

| 禁止行为 | 说明 |
|---------|------|
| ❌ 输出"技术方案要点" | 这是 /design 的职责 |
| ❌ 输出"涉及模块"详细列表 | 这是 /design 的职责 |
| ❌ 输出"风险点"分析 | 这是 /design 的职责 |
| ❌ 跳过 `/explore` 直接进入 `/design` | 必须按顺序 |
| ❌ 在澄清阶段写任何实现代码 | 只输出 AC 文档 |

**正确的完成动作**：
1. 输出 AC 文档到 `docs/需求澄清/clarify_[功能名].md`
2. 展示完成提示
3. 进入下一环节 `/explore`（正常流转）或等待用户指令

### 核心改进点

1. **分级处理**：简单需求快速确认，复杂需求深度澄清
2. **快捷回复**：`ok` 接受默认，`1a 2b` 快速选择
3. **职责瘦身**：只输出 AC，不输出技术方案
4. **不要无脑提问**：先研究项目，再精准提问

### 时间控制

- 研究阶段：快速浏览，不要深入细节
- 简单需求：1 轮快速确认
- 中等需求：2 轮精准提问
- 复杂需求：3 轮深度澄清
- 如果 3 轮还没澄清，可能需求本身不清晰，建议用户先梳理

---

## 与其他 Skills 的关系

```
/clarify（需求澄清）← 当前，AC 单一来源
    ↓ 输出：AC 文档（不含技术方案）
    ↓ [评审点: 需求评审]
/explore（方案探索）
    ↓ 方案确定后
/design（架构设计）← 技术方案在这里输出
    ↓ [评审点: 架构评审]
/plan（写计划）
    ↓ ⚠️ 引用 /clarify 的 AC，禁止重新定义
    ↓ [评审点: 计划评审]
/test-gen from-clarify  ← 测试先行
    ↓ 从 AC 表格生成 FAILING 测试
    ↓ [门控: 测试必须存在才能开发]
/run-plan（执行计划）
    ↓ 严格 TDD，基于已有测试开发
/check（开发检查）
    ↓
/qa（测试验收）
    ↓ 基于 AC 表格验收
```

### AC 流转链路

```
/clarify 定义 AC（单一来源）
    ↓
/plan 引用 AC（禁止重新定义）
    ↓
/test-gen 从 AC 生成测试
    ↓
/run-plan 基于测试开发（TDD）
    ↓
/qa 基于 AC 验收
```

**核心原则**：AC 只在 /clarify 定义一次，后续所有阶段只能引用，不能修改或重新定义。

### AC 防篡改机制（技术门控）

> **目的**：防止 /plan 阶段无意或有意修改 AC，确保 AC 从定义到验收的完整性。

**机制说明**：

1. **AC 指纹生成**（/clarify 阶段）
   - 对 AC 表格内容计算 hash（取 AC-ID + Given + When + Then + 优先级的拼接字符串）
   - 格式：`AC-HASH-XXXXXXXX`（MD5 前 8 位）
   - 写入 AC 文档的"验收标准"标题下方

2. **AC 指纹验证**（/plan 阶段门控）
   - /plan 启动时，读取 clarify 文档中的 AC 指纹
   - 重新计算当前 AC 表格的 hash
   - 比对两个 hash 值

3. **验证结果处理**：

| 结果 | 处理 |
|------|------|
| hash 匹配 | ✅ 继续执行 /plan |
| hash 不匹配 | ❌ 中止，报告差异，要求走 /clarify 变更流程 |
| clarify 文档不存在 | ❌ 中止，提示先执行 /clarify |
| AC 指纹缺失 | ⚠️ 警告，建议重新执行 /clarify |

4. **AC 变更流程**（如果确实需要修改 AC）：
   ```
   发现 AC 需要修改
       ↓
   执行 /clarify --amend [功能名]
       ↓
   更新 AC + 重新生成指纹
       ↓
   继续 /plan
   ```

**指纹计算范围**：
- 包含：AC-ID、Given、When、Then、优先级
- 不包含：测试方法（允许调整）

**指纹计算示例**：
```python
import hashlib

def calculate_ac_hash(ac_table):
    """计算 AC 表格的指纹"""
    content = ""
    for ac in ac_table:
        content += f"{ac['id']}|{ac['given']}|{ac['when']}|{ac['then']}|{ac['priority']}"
    return "AC-HASH-" + hashlib.md5(content.encode()).hexdigest()[:8].upper()
```

---

## 快速判断：是否需要 /clarify？

| 情况 | 是否需要 |
|------|---------|
| 用户说"帮我做 XXX"，XXX 很模糊 | ✅ 需要 |
| 用户给了详细的需求文档 | ❌ 可跳过 |
| 用户说"按上次讨论的做" | ⚠️ 快速确认关键点 |
| 小改动、Bug 修复 | ❌ 可跳过 |
| 复杂功能、涉及多模块 | ✅ 需要 |
| 性能优化、架构调整 | ✅ 需要（必须先研究现状） |

---

## ✅ 完成提示

### 简单需求完成提示

```
✅ 需求澄清完成

📁 文档已保存至：docs/需求澄清/clarify_[功能名].md
📊 AC 表格：X 条
🏷️ 复杂度：简单

🎯 下一步：
- 需求简单明确，可直接执行 /design 或 /plan
- 如需调研业界方案，执行 /explore
```

### 中等/复杂需求完成提示

```
✅ 需求澄清完成

📁 文档已保存至：docs/需求澄清/clarify_[功能名].md
📊 AC 表格：X 条（正常 X + 异常 X + 边界 X）
🏷️ 复杂度：[中等 / 复杂]
🔐 AC 指纹：AC-HASH-XXXXXXXX

⚠️ AC 单一来源声明：
   此 AC 表格是整个开发流程的唯一验收标准
   后续 /plan、/test-gen、/qa 必须引用，禁止重新定义
   AC 指纹将在 /plan 阶段自动验证，防止被意外修改

🎯 下一步建议：
1. 用户确认需求理解和 AC 表格无误
2. [评审] 进行需求评审（建议使用 /critique）
3. 执行 /explore（方案探索）- 调研业界最佳实践
4. 执行 /design（架构设计）- 输出技术方案

现在进入下一步？
```
