---
name: run-plan
command: run-plan
user_invocable: true
description: 执行计划。支持两种执行模式：依赖链模式（按依赖拓扑排序）和多人协作模式（按功能分派开发者，效率提升 2-5 倍）。内置严格 TDD 和完成前验证。在写计划（/plan）之后、开发检查（/check）之前使用。
---

# 执行计划 (Run Plan)

> **角色**：Tech Lead，负责任务分派、协调和集成
> **流程**：`/plan` 之后 → `/check` 之前

---

## 文档契约（铁律）

> **原则**：没有输入文档 → 不能执行；没有输出文档 → 不算完成

### 输入文档（门控检查）

| 文档 | 路径 | 必须 | 检查命令 |
|------|------|------|---------|
| **AC 文档** | `docs/需求文档/clarify_[功能名].md` | ✅ 必须 | `ls docs/需求文档/clarify_*.md` |
| **计划文档** | `docs/开发文档/plan_[功能名].md` | ✅ 必须 | `ls docs/开发文档/plan_*.md` |
| **FAILING 测试** | `tests/test_[功能名]_acceptance.py` | ✅ 必须 | `ls tests/test_*_acceptance.py` |

**门控失败处理**：
- AC 文档不存在 → **停止执行**，先执行 `/clarify`
- 计划文档不存在 → **停止执行**，先执行 `/plan`
- FAILING 测试不存在 → **停止执行**，先执行 `/test-gen from-clarify <clarify_doc>`
- 禁止跳过门控检查

### 输出文档

| 文档 | 路径 | 用途 |
|------|------|------|
| **更新后的计划文档** | `docs/开发文档/plan_[功能名].md` | checkbox 状态更新 |

**输出规则**：
- 每个 Task 完成后立即更新 checkbox 状态
- 完成提示必须包含执行统计和验证结果

**下游依赖**：
- `/check` 依赖计划文档的 checkbox 状态
- `/qa` 依赖开发完成的代码和测试

---

## 触发条件

当用户使用以下任一方式时，立即激活此 skill：
- 说"**开始开发**"或"**执行计划**"（主触发词）
- 使用命令：`/run-plan`
- 说"干活"、"开始干"
- 说"按计划执行"
- 说"开工"

**调用方式**：

```bash
# 方式1: 自动扫描（默认）
/run-plan

# 方式2: 指定计划文档（推荐，/clear 后使用）
/run-plan docs/开发文档/plan_用户认证.md
```

**推荐使用方式2**：
- `/clear` 后上下文丢失，指定文件路径更可靠
- 有多个计划文档时，避免执行错误的计划
- 完成提示中会给出可复制的完整命令

---

## 🚨 执行前门控检查（必须通过）

> **测试先行原则**：没有测试的开发不是 TDD

**门控检查清单**：

```
┌────────────────────────────────────────────────────────────────┐
│ 🔒 门控 1: AC 来源文档存在                                      │
│    检查: docs/需求文档/clarify_[功能名].md 是否存在              │
│    失败: 先执行 /clarify 生成需求文档和 AC 表格                   │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ 🔒 门控 2: 计划文档引用 AC（非重新定义）                          │
│    检查: /plan 文档中是否引用 /clarify 的 AC                     │
│    失败: 修改 /plan 文档，改为引用 AC 而非重新定义                 │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ 🔒 门控 3: FAILING 测试已生成                                   │
│    检查: tests/test_[功能名]_acceptance.py 是否存在              │
│    失败: 先执行 /test-gen from-clarify <clarify_doc>            │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ ✅ 门控通过，继续执行                                            │
└────────────────────────────────────────────────────────────────┘
```

**门控失败时的处理**：

```
⛔ 门控检查失败

❌ 缺失项:
   - [ ] AC 来源文档: docs/需求文档/clarify_用户认证.md
   - [ ] FAILING 测试: tests/test_auth_acceptance.py

🔧 修复步骤:
   1. 如果 AC 文档不存在: 执行 /clarify
   2. 如果测试不存在: 执行 /test-gen from-clarify <clarify_doc>
   3. 修复后重新执行 /run-plan

💡 为什么需要门控？
   - 测试是开发的验收标准，先有标准才有实现
   - 避免"先写代码后补测试"的假 TDD
   - 保证 AC → 测试 → 代码的一致性链路
```

---

## ⚠️ 执行前必读（铁律）

**门控通过后，必须按以下顺序加载文件**：

```
┌────────────────────────────────────────────────────────────────┐
│ 步骤 1: 读取本文件 (SKILL.md)                                   │
│         理解总体框架、执行模式、核心原则                          │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ 步骤 2: 读取 Tech Lead 操作手册                                 │
│         ~/.claude/skills/执行计划_run-plan/prompts/tech-lead.md │
│         按手册步骤执行，这是你的详细操作指南                      │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ 步骤 3: 派发任务时，读取 Implementer 规范                        │
│         ~/.claude/skills/执行计划_run-plan/prompts/implementer.md│
│         作为子代理的 prompt 模板，组装后发送给子代理              │
└────────────────────────────────────────────────────────────────┘
```

**禁止行为**：
- ❌ 跳过门控检查直接执行（测试不存在）
- ❌ 只读 SKILL.md 就开始执行（缺少详细操作步骤）
- ❌ 跳过 tech-lead.md 直接派发任务（不知道如何组装 prompt）
- ❌ 不读 implementer.md 就创建子代理（子代理没有执行规范）

---

## 三文件配合流程图

```
用户执行 /run-plan
       ↓
┌──────────────────────────────────────────────────────────────┐
│ SKILL.md (本文件)                                            │
│ ─────────────────                                            │
│ 你读取本文件，理解：                                           │
│ • 自己是 Tech Lead 角色                                       │
│ • 有两种执行模式（多人协作/依赖链）                              │
│ • 核心原则是什么                                              │
│                                                              │
│ 然后立即读取 tech-lead.md ↓                                   │
└──────────────────────────────────────────────────────────────┘
       ↓
┌──────────────────────────────────────────────────────────────┐
│ tech-lead.md (Tech Lead 操作手册)                             │
│ ────────────────────────────────                              │
│ 你按照此手册的步骤操作：                                        │
│ • 第一步：读取计划文档                                         │
│ • 第二步：分组执行                                             │
│ • 第三步：完成前置工作                                         │
│ • 第四步：组装子代理 prompt ──┐                                │
│ • 第五步：处理返回结果        │                                │
│ • 第六步：状态更新            │                                │
│ • 第七步：服务启动验证        │                                │
│ • 第八步：中断恢复            │                                │
└───────────────────────────────│──────────────────────────────┘
                                ↓
┌──────────────────────────────────────────────────────────────┐
│ implementer.md (子代理 Prompt 模板)                           │
│ ─────────────────────────────────                             │
│ 你读取此文件，作为子代理的 prompt 模板                          │
│                                                              │
│ 组装方式：                                                    │
│ ┌──────────────────────────────────────────────────────────┐ │
│ │ <Task description="Alice 执行登录功能">                   │ │
│ │   [implementer.md 的内容]                                │ │
│ │   +                                                      │ │
│ │   [任务参数: 角色=Alice, 文件范围=login.py, 任务详情...]   │ │
│ │ </Task>                                                  │ │
│ └──────────────────────────────────────────────────────────┘ │
│                                                              │
│ 子代理 Alice/Bob/Charlie 按此规范执行：                        │
│ • 严格 TDD                                                   │
│ • 只修改分配的文件                                            │
│ • 完成前验证                                                  │
│ • 返回完成报告或问题报告                                       │
└──────────────────────────────────────────────────────────────┘
```

---

## 操作手册（执行时必读）

| 手册 | 路径 | 用途 | 加载时机 |
|------|------|------|---------|
| **Tech Lead 操作手册** | `~/.claude/skills/执行计划_run-plan/prompts/tech-lead.md` | 你的详细操作指南 | 读完 SKILL.md 后立即读取 |
| **Implementer 规范** | `~/.claude/skills/执行计划_run-plan/prompts/implementer.md` | 子代理的 prompt 模板 | 派发任务时读取并组装 |

---

## 参考规范

| 规范 | 路径 | 用途 |
|------|------|------|
| **TDD 规范** | `~/.claude/reference/TDD规范.md` | 严格 TDD 流程 |
| **完成前验证** | `~/.claude/reference/完成前验证.md` | 验证清单 |
| **并行拆分策略** | `~/.claude/reference/并行拆分策略.md` | 多人协作拆分原则 |

---

## 执行模式

### 模式识别（根据计划文档自动判断）

| 模式 | 识别特征 | 适用场景 | 效率提升 |
|------|---------|---------|---------|
| **多人协作模式** | Tasks 表格有"负责人"列 | 功能独立、文件不冲突 | **2-5 倍** |
| **依赖链模式** | Tasks 表格无"负责人"列 | 强依赖、功能耦合 | 40-60% |

### 多人协作模式架构（推荐）

```
Tech Lead 前置工作（基础设施）
    ↓
开发者并行执行
┌─────────┐  ┌─────────┐  ┌─────────┐
│ Alice   │  │ Bob     │  │ Charlie │ ← 并行
│ 登录功能│  │ 注册功能│  │ 重置密码│
└─────────┘  └─────────┘  └─────────┘
    ↓ 等待全部完成
Tech Lead 后置工作（集成 + 服务启动验证）
    ↓
/check
```

### 依赖链模式架构

```
按依赖分组（拓扑排序）→ 组内并行 → 组间串行 → 服务启动验证 → /check
```

---

## 核心原则

| 原则 | 说明 |
|------|------|
| **测试先行** | 测试在开发之前生成（/test-gen from-clarify），不是开发中生成 |
| **职责边界清晰** | 每个开发者负责完整功能（前+后端），不越界 |
| **文件隔离** | 每个开发者只修改分配的文件，避免冲突 |
| **严格 TDD** | 基于已有的 FAILING 测试，实现代码让测试通过 |
| **完成前验证** | 必须亲眼看到验证命令成功，才能声明完成 |
| **服务启动验证** | 集成后必须验证服务能正常启动并响应请求 |

### 严格 TDD 流程（基于已有测试）

```
开发者收到任务
    ↓
[确认] 测试文件已存在（/test-gen 已生成）
    ↓
运行测试 → 🔴 RED（测试失败）← 必须看到
    ↓
写最小代码让测试通过
    ↓
运行测试 → 🟢 GREEN（测试通过）← 必须看到
    ↓
重构（保持测试绿色）
    ↓
声明完成
```

**⚠️ TDD 铁律**：
- 没有先失败的测试，就没有生产代码
- 测试之前就写了代码？**删掉它，重新开始**
- 测试立即通过？你在测试已有行为，修复测试

---

## 角色分工

### Tech Lead（你）

**职责**：
1. 读取计划 → 识别执行模式
2. 完成基础设施（前置工作）
3. 派发任务 → 监控进度 → 处理问题
4. 合并代码 → **服务启动验证**（后置工作）

**详细操作**：见 `~/.claude/skills/执行计划_run-plan/prompts/tech-lead.md`

### 开发者 Alice/Bob/Charlie（子代理）

**职责**：
- **只修改分配的文件**（禁止越界）
- **遵循严格 TDD**（RED-GREEN-REFACTOR）
- **完成前验证**（亲眼看到命令成功）
- 提交结果（代码 + 测试报告）

**执行规范**：见 `~/.claude/skills/执行计划_run-plan/prompts/implementer.md`

**文件边界约束（铁律）**：
```
❌ 禁止：Alice 修改 Bob 负责的 register.py
✅ 允许：Alice 只修改 login.py, LoginForm.tsx
```

---

## 执行流程概述

```
0. 🔒 门控检查（必须通过）
   ├─ AC 来源文档存在
   ├─ 计划引用 AC（非重新定义）
   └─ FAILING 测试已生成
    ↓
1. 读取计划文档，解析 Tasks 表格
    ↓
2. 识别执行模式（多人协作 / 依赖链）
    ↓
3. 分组执行
   ├─ 多人协作: Tech Lead前置 → 开发者并行 → Tech Lead后置
   └─ 依赖链: 拓扑排序 → 组内并行 → 组间串行
    ↓
4. 派发任务（基于已有测试，严格 TDD）
    ↓
5. 处理结果（成功→更新状态，失败→/debug分析→重试）
    ↓
6. 服务启动验证
    ↓
7. 完成
```

**详细步骤**：见 `~/.claude/skills/执行计划_run-plan/prompts/tech-lead.md`

---

## 状态更新

**每个 Task 完成后立即更新**（不等批次结束）：

1. 更新计划文档 checkbox: `- [ ] T1` → `- [x] T1`
2. 更新 TaskUpdate: status → completed

**为什么立即更新**：
- 支持中断恢复
- 进度可见
- 避免重复执行

---

## 服务启动验证（铁律）

> 如果没有看到服务正常启动并响应请求，就不能声称完成。

```bash
# 启动服务
python -m uvicorn app.main:app &
sleep 3

# 验证健康检查
curl -f http://localhost:8000/health || echo "❌ 失败"

# 停止服务
kill %1
```

**验证清单**：
- [ ] 服务启动无报错
- [ ] 健康检查端点响应 200
- [ ] 核心 API 能正常响应

---

## 中断恢复

- **权威来源**：计划文档 checkbox
- **恢复方式**：重新执行 /run-plan，自动从 checkbox 状态恢复
- **扫描路径**：`docs/开发文档/plan_*.md`

---

## ⛔ 边界约束（铁律）

> **`/run-plan` 的职责边界：只做计划执行，不能跳过后续环节**

| 禁止行为 | 说明 |
|---------|------|
| ❌ 跳过 `/check` 直接进入 `/qa` | 必须按顺序：run-plan → check → qa |
| ❌ 跳过 `/qa` 直接进入 `/ship` | 必须通过测试验收 |

**正确的完成动作**：
1. 更新计划文档的 checkbox 状态
2. 展示完成提示（包含执行统计和验证结果）
3. 进入下一环节 `/check`（正常流转）或等待用户指令

**跳过环节的处理**：
- `/check` 和 `/qa` 都不能跳过，这是质量门控

---

## 禁止行为

| 禁止 | 原因 |
|------|------|
| **跳过门控检查** | 没有测试的开发不是 TDD |
| **测试不存在就开发** | 违反测试先行原则 |
| 串行执行所有 Tasks | 失去并行优势 |
| 跳过 TDD | 代码质量无保证 |
| 不更新 checkbox | 无法中断恢复 |
| 假设性完成 | 必须有实际执行结果 |
| 等批次结束才更新状态 | 中断时状态丢失 |
| 跳过服务启动验证 | 集成问题无法发现 |
| 不读 tech-lead.md 就执行 | 缺少详细操作步骤 |
| **开发中生成测试** | 测试应在开发前由 /test-gen 生成 |
| **测试之前写代码** | 删掉代码，重新开始 |

---

## ✅ 完成提示

```
✅ 计划执行完成

📊 执行统计:
- 执行模式: 多人协作模式
- 并行开发者: Alice, Bob, Charlie
- 效率提升: 2-5 倍

📋 开发者完成情况:
- Alice (登录功能): ✅ TDD 通过, 验证通过
- Bob (注册功能): ✅ TDD 通过, 验证通过
- Charlie (密码重置): ✅ TDD 通过, 验证通过

🔧 Tech Lead 集成验证:
- 服务启动: ✅ 健康检查通过

下一步: /check（开发检查）
```

---

**版本**：v3.1（分层架构 + 加载顺序明确 + 配合流程图）
**更新日期**：2025-01-28
