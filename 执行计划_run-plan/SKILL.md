---
name: run-plan
command: run-plan
user_invocable: true
description: 执行计划。支持两种执行模式：依赖链模式（按依赖拓扑排序）和多人协作模式（按功能分派开发者，效率提升 2-5 倍）。内置严格 TDD 和完成前验证。在写计划（/plan）之后、开发检查（/check）之前使用。
---

# 执行计划 (Run Plan)

> **角色**：Tech Lead，负责任务分派、协调和集成
> **流程**：`/plan` 之后 → `/check` 之前

---

## 文档契约（铁律）

> **原则**：没有输入文档 → 不能执行；没有输出文档 → 不算完成

### 输入文档（门控检查）

| 文档 | 路径 | 必须 | 检查标准 |
|------|------|------|---------|
| **AC 文档** | `docs/需求澄清/clarify_[功能名].md` | ✅ 必须 | 文件存在 + 至少 3 条 AC + 覆盖正常/异常/边界 |
| **计划文档** | `docs/开发文档/plan_[功能名].md` | ✅ 必须 | 文件存在 + 文件边界无冲突 |
| **FAILING 测试** | `tests/test_[功能名]_acceptance.py` | ✅ 必须 | 文件存在 + 有测试用例 + 运行是 RED 状态 |

**门控失败处理**：
- AC 文档不存在 → **停止执行**，先执行 `/clarify`
- AC 少于 3 条或缺少场景覆盖 → **停止执行**，补充 AC 后重新 `/clarify`
- 计划文档不存在 → **停止执行**，先执行 `/plan`
- 计划文档文件边界冲突 → **停止执行**，修正 `/plan` 中的文件分配
- FAILING 测试不存在 → **停止执行**，先执行 `/test-gen from-clarify <clarify_doc>`
- 测试不是 RED 状态 → **停止执行**，检查测试是否正确实现
- 禁止跳过门控检查

### 输出文档

| 文档 | 路径 | 用途 |
|------|------|------|
| **更新后的计划文档** | `docs/开发文档/plan_[功能名].md` | checkbox 状态更新 |

**输出规则**：
- 每个 Task 完成后立即更新 checkbox 状态
- 完成提示必须包含执行统计和验证结果

**下游依赖**：
- `/check` 依赖计划文档的 checkbox 状态
- `/qa` 依赖开发完成的代码和测试

---

## 触发条件

当用户使用以下任一方式时，立即激活此 skill：
- 说"**开始开发**"或"**执行计划**"（主触发词）
- 使用命令：`/run-plan`
- 说"干活"、"开始干"
- 说"按计划执行"
- 说"开工"

**调用方式**：

```bash
# 方式1: 自动扫描（默认）
/run-plan

# 方式2: 指定计划文档（推荐，/clear 后使用）
/run-plan docs/开发文档/plan_用户认证.md
```

**推荐使用方式2**：
- `/clear` 后上下文丢失，指定文件路径更可靠
- 有多个计划文档时，避免执行错误的计划
- 完成提示中会给出可复制的完整命令

---

## 🚨 执行前门控检查（必须通过）

> **测试先行原则**：没有测试的开发不是 TDD

**门控检查清单**：

```
┌────────────────────────────────────────────────────────────────┐
│ 🔒 门控 1: AC 文档质量检查                                       │
│    检查项:                                                       │
│    ├─ 文件存在: docs/需求澄清/clarify_[功能名].md                 │
│    ├─ AC 数量: 至少 3 条 AC                                      │
│    └─ 场景覆盖: 有正常场景 + 异常场景 + 边界场景                   │
│    失败: 先执行 /clarify 生成完整的需求文档                        │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ 🔒 门控 2: 计划文档边界检查                                       │
│    检查项:                                                       │
│    ├─ 文件存在: docs/开发文档/plan_[功能名].md                    │
│    ├─ 引用 AC: 引用 /clarify 的 AC（非重新定义）                  │
│    └─ 文件边界无冲突: 不同 Task 的文件范围不重叠                   │
│    失败: 修正 /plan 文档，确保文件分配无冲突                       │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ 🔒 门控 3: 测试 RED 状态检查                                     │
│    检查项:                                                       │
│    ├─ 文件存在: tests/test_[功能名]_acceptance.py                │
│    ├─ 有测试用例: 至少 1 个 test_ 函数                           │
│    └─ RED 状态: 运行测试结果为 FAILED（非 PASSED/ERROR）          │
│    失败: 先执行 /test-gen from-clarify <clarify_doc>             │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ 🔒 门控 4: 基础设施启动验证（新增）                               │
│    检查项:                                                       │
│    └─ 服务能正常启动并响应健康检查                                │
│    失败: 修复基础设施问题后重试                                   │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ ✅ 所有门控通过，继续执行                                         │
└────────────────────────────────────────────────────────────────┘
```

**门控失败时的处理**：

```
⛔ 门控检查失败

❌ 失败项:
   - [ ] 门控1 AC 文档质量:
         ├─ 文件存在: ✅
         ├─ AC 数量(>=3): ❌ 当前 2 条
         └─ 场景覆盖: ❌ 缺少边界场景
   - [ ] 门控2 计划文档边界:
         ├─ 文件存在: ✅
         └─ 文件边界无冲突: ❌ login.py 被多个 Task 引用
   - [ ] 门控3 测试 RED 状态:
         ├─ 文件存在: ✅
         ├─ 有测试用例: ✅
         └─ RED 状态: ❌ 当前是 GREEN（已通过）
   - [ ] 门控4 基础设施启动:
         └─ 服务能启动: ❌ 导入错误

🔧 修复步骤:
   1. AC 数量不足: 补充 AC 后重新执行 /clarify
   2. 场景覆盖不完整: 确保有正常/异常/边界场景
   3. 文件边界冲突: 修正 /plan，确保每个文件只分配给一个 Task
   4. 测试不是 RED: 检查测试是否正确定义预期行为
   5. 基础设施无法启动: 先修复导入/配置问题
   6. 全部修复后重新执行 /run-plan

💡 为什么需要增强门控？
   - AC 质量保证需求完整性，避免遗漏场景
   - 文件边界检查避免并行开发时的冲突
   - 测试 RED 状态确保真正的 TDD，而非事后补测试
   - 基础设施预验证避免任务派发后才发现环境问题
```

---

## ⚠️ 执行前必读（铁律）

**门控通过后，必须按以下顺序加载文件**：

```
┌────────────────────────────────────────────────────────────────┐
│ 步骤 1: 读取本文件 (SKILL.md)                                   │
│         理解总体框架、执行模式、核心原则                          │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ 步骤 2: 读取 Tech Lead 操作手册                                 │
│         ~/.claude/skills/执行计划_run-plan/prompts/tech-lead.md │
│         按手册步骤执行，这是你的详细操作指南                      │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│ 步骤 3: 派发任务时，读取 Implementer 规范                        │
│         ~/.claude/skills/执行计划_run-plan/prompts/implementer.md│
│         作为子代理的 prompt 模板，组装后发送给子代理              │
└────────────────────────────────────────────────────────────────┘
```

**禁止行为**：
- ❌ 跳过门控检查直接执行（测试不存在）
- ❌ 只读 SKILL.md 就开始执行（缺少详细操作步骤）
- ❌ 跳过 tech-lead.md 直接派发任务（不知道如何组装 prompt）
- ❌ 不读 implementer.md 就创建子代理（子代理没有执行规范）

---

## 三文件配合流程图

```
用户执行 /run-plan
       ↓
┌──────────────────────────────────────────────────────────────┐
│ SKILL.md (本文件)                                            │
│ ─────────────────                                            │
│ 你读取本文件，理解：                                           │
│ • 自己是 Tech Lead 角色                                       │
│ • 有两种执行模式（多人协作/依赖链）                              │
│ • 核心原则是什么                                              │
│                                                              │
│ 然后立即读取 tech-lead.md ↓                                   │
└──────────────────────────────────────────────────────────────┘
       ↓
┌──────────────────────────────────────────────────────────────┐
│ tech-lead.md (Tech Lead 操作手册)                             │
│ ────────────────────────────────                              │
│ 你按照此手册的步骤操作：                                        │
│ • 第一步：读取计划文档                                         │
│ • 第二步：分组执行                                             │
│ • 第三步：完成前置工作                                         │
│ • 第四步：组装子代理 prompt ──┐                                │
│ • 第五步：处理返回结果        │                                │
│ • 第六步：状态更新            │                                │
│ • 第七步：服务启动验证        │                                │
│ • 第八步：中断恢复            │                                │
└───────────────────────────────│──────────────────────────────┘
                                ↓
┌──────────────────────────────────────────────────────────────┐
│ implementer.md (子代理 Prompt 模板)                           │
│ ─────────────────────────────────                             │
│ 你读取此文件，作为子代理的 prompt 模板                          │
│                                                              │
│ 组装方式：                                                    │
│ ┌──────────────────────────────────────────────────────────┐ │
│ │ <Task description="Alice 执行登录功能">                   │ │
│ │   [implementer.md 的内容]                                │ │
│ │   +                                                      │ │
│ │   [任务参数: 角色=Alice, 文件范围=login.py, 任务详情...]   │ │
│ │ </Task>                                                  │ │
│ └──────────────────────────────────────────────────────────┘ │
│                                                              │
│ 子代理 Alice/Bob/Charlie 按此规范执行：                        │
│ • 严格 TDD                                                   │
│ • 只修改分配的文件                                            │
│ • 完成前验证                                                  │
│ • 返回完成报告或问题报告                                       │
└──────────────────────────────────────────────────────────────┘
```

---

## 操作手册（执行时必读）

| 手册 | 路径 | 用途 | 加载时机 |
|------|------|------|---------|
| **Tech Lead 操作手册** | `~/.claude/skills/执行计划_run-plan/prompts/tech-lead.md` | 你的详细操作指南 | 读完 SKILL.md 后立即读取 |
| **Implementer 规范** | `~/.claude/skills/执行计划_run-plan/prompts/implementer.md` | 子代理的 prompt 模板 | 派发任务时读取并组装 |

---

## 参考规范

| 规范 | 路径 | 用途 |
|------|------|------|
| **TDD 规范** | `~/.claude/reference/TDD规范.md` | 严格 TDD 流程 |
| **完成前验证** | `~/.claude/reference/完成前验证.md` | 验证清单 |
| **并行拆分策略** | `~/.claude/reference/并行拆分策略.md` | 多人协作拆分原则 |

---

## 执行模式

### 模式识别（根据计划文档自动判断）

| 模式 | 识别特征 | 适用场景 | 效率提升 |
|------|---------|---------|---------|
| **多人协作模式** | Tasks 表格有"负责人"列 | 功能独立、文件不冲突 | **2-5 倍** |
| **依赖链模式** | Tasks 表格无"负责人"列 | 强依赖、功能耦合 | 40-60% |

### 多人协作模式架构（推荐）

```
🔒 门控检查（含基础设施启动验证）
    ↓ 验证通过后才派发任务
Tech Lead 前置工作（基础设施）
    ↓ 📊 输出进度 [██░░░░░░░░░░░░░░] 10%
开发者并行执行
┌─────────┐  ┌─────────┐  ┌─────────┐
│ Alice   │  │ Bob     │  │ Charlie │ ← 并行
│ 登录功能│  │ 注册功能│  │ 重置密码│
└─────────┘  └─────────┘  └─────────┘
    ↓ 每个完成后输出进度 📊
Tech Lead 后置工作（集成 + 服务启动验证）
    ↓ 📊 输出进度 [████████████████] 100%
/check
```

### 依赖链模式架构

```
按依赖分组（拓扑排序）→ 组内并行 → 组间串行 → 服务启动验证 → /check
```

---

## 核心原则

| 原则 | 说明 |
|------|------|
| **测试先行** | 测试在开发之前生成（/test-gen from-clarify），不是开发中生成 |
| **职责边界清晰** | 每个开发者负责完整功能（前+后端），不越界 |
| **文件隔离** | 每个开发者只修改分配的文件，避免冲突 |
| **严格 TDD** | 基于已有的 FAILING 测试，实现代码让测试通过 |
| **完成前验证** | 必须亲眼看到验证命令成功，才能声明完成 |
| **服务启动验证** | 集成后必须验证服务能正常启动并响应请求 |

### 严格 TDD 流程（基于已有测试）

```
开发者收到任务
    ↓
[确认] 测试文件已存在（/test-gen 已生成）
    ↓
运行测试 → 🔴 RED（测试失败）← 必须看到
    ↓
写最小代码让测试通过
    ↓
运行测试 → 🟢 GREEN（测试通过）← 必须看到
    ↓
重构（保持测试绿色）
    ↓
声明完成
```

**⚠️ TDD 铁律**：
- 没有先失败的测试，就没有生产代码
- 测试之前就写了代码？**删掉它，重新开始**
- 测试立即通过？你在测试已有行为，修复测试

---

## 角色分工

### Tech Lead（你）

**职责**：
1. 读取计划 → 识别执行模式
2. 完成基础设施（前置工作）
3. 派发任务 → 监控进度 → 处理问题
4. 合并代码 → **服务启动验证**（后置工作）

**详细操作**：见 `~/.claude/skills/执行计划_run-plan/prompts/tech-lead.md`

### 开发者 Alice/Bob/Charlie（子代理）

**职责**：
- **只修改分配的文件**（禁止越界）
- **遵循严格 TDD**（RED-GREEN-REFACTOR）
- **完成前验证**（亲眼看到命令成功）
- 提交结果（代码 + 测试报告）

**执行规范**：见 `~/.claude/skills/执行计划_run-plan/prompts/implementer.md`

**文件边界约束（铁律）**：
```
❌ 禁止：Alice 修改 Bob 负责的 register.py
✅ 允许：Alice 只修改 login.py, LoginForm.tsx
```

---

## 执行流程概述

```
0. 🔒 门控检查（必须全部通过）
   ├─ AC 文档质量: 至少 3 条 AC + 场景覆盖完整
   ├─ 计划文档边界: 文件边界无冲突
   ├─ 测试 RED 状态: 文件存在 + 有测试用例 + 运行失败
   └─ 基础设施启动: 服务能正常启动并响应（新增）
    ↓
1. 读取计划文档，解析 Tasks 表格
    ↓
2. 识别执行模式（多人协作 / 依赖链）
    ↓
3. 分组执行
   ├─ 多人协作: Tech Lead前置 → 开发者并行 → Tech Lead后置
   └─ 依赖链: 拓扑排序 → 组内并行 → 组间串行
    ↓
4. 派发任务（基于已有测试，严格 TDD）
    ↓ 每个 Task 完成后输出进度条（新增）
5. 处理结果（成功→更新状态，失败→/debug分析→重试）
    ↓
6. 服务启动验证（最终集成验证）
    ↓
7. 完成
```

**详细步骤**：见 `~/.claude/skills/执行计划_run-plan/prompts/tech-lead.md`

---

## 状态更新

**每个 Task 完成后立即更新**（不等批次结束）：

1. 更新计划文档 checkbox: `- [ ] T1` → `- [x] T1`
2. 更新 TaskUpdate: status → completed

**为什么立即更新**：
- 支持中断恢复
- 进度可见
- 避免重复执行

---

## 实时进度反馈

> 每个 Task 完成后输出进度条，让用户实时了解执行进度

### 进度条格式

```
📊 执行进度 [████████░░░░░░░░] 50% (3/6)

已完成:
  ✅ T0: 基础设施 (Tech Lead)
  ✅ T1: 登录功能 (Alice)
  ✅ T2: 注册功能 (Bob)

进行中:
  🔄 T3: 密码重置 (Charlie)

待执行:
  ⏳ T4: 集成测试 (Tech Lead)
  ⏳ T5: 文档更新 (Tech Lead)
```

### 进度更新时机

| 时机 | 动作 |
|------|------|
| Task 开始执行 | 更新状态为 🔄 进行中 |
| Task 完成 | 更新状态为 ✅ 已完成，刷新进度条 |
| Task 失败 | 更新状态为 ❌ 失败，显示错误摘要 |
| 批次完成 | 显示批次完成提示 |

### 批次完成提示

```
════════════════════════════════════════════════════════════════
✅ 批次 2 完成（开发者并行批次）
   - Alice (登录功能): ✅ TDD 通过
   - Bob (注册功能): ✅ TDD 通过
   - Charlie (密码重置): ✅ TDD 通过
════════════════════════════════════════════════════════════════
```

---

## 服务启动验证（铁律）

> 如果没有看到服务正常启动并响应请求，就不能声称完成。

```bash
# 启动服务
python -m uvicorn app.main:app &
sleep 3

# 验证健康检查
curl -f http://localhost:8000/health || echo "❌ 失败"

# 停止服务
kill %1
```

**验证清单**：
- [ ] 服务启动无报错
- [ ] 健康检查端点响应 200
- [ ] 核心 API 能正常响应

---

## 中断恢复

- **权威来源**：计划文档 checkbox
- **恢复方式**：重新执行 /run-plan，自动从 checkbox 状态恢复
- **扫描路径**：`docs/开发文档/plan_*.md`

---

## ⛔ 边界约束（铁律）

> **`/run-plan` 的职责边界：只做计划执行，不能跳过后续环节**

| 禁止行为 | 说明 |
|---------|------|
| ❌ 跳过 `/check` 直接进入 `/qa` | 必须按顺序：run-plan → check → qa |
| ❌ 跳过 `/qa` 直接进入 `/ship` | 必须通过测试验收 |

**正确的完成动作**：
1. 更新计划文档的 checkbox 状态
2. 展示完成提示（包含执行统计和验证结果）
3. 进入下一环节 `/check`（正常流转）或等待用户指令

**跳过环节的处理**：
- `/check` 和 `/qa` 都不能跳过，这是质量门控

---

## 禁止行为

| 禁止 | 原因 |
|------|------|
| **跳过门控检查** | 没有测试的开发不是 TDD |
| **门控只检查文件存在** | 必须检查内容质量（AC 数量、测试状态等） |
| **测试是 GREEN 就开发** | RED 状态是 TDD 的起点，GREEN 说明测试无效 |
| **文件边界有冲突就派发** | 并行开发时会产生代码冲突 |
| **基础设施坏了就派发任务** | 任务会全部失败，浪费资源 |
| 串行执行所有 Tasks | 失去并行优势 |
| 跳过 TDD | 代码质量无保证 |
| 不更新 checkbox | 无法中断恢复 |
| **不输出进度条** | 用户无法了解执行进度 |
| 假设性完成 | 必须有实际执行结果 |
| 等批次结束才更新状态 | 中断时状态丢失 |
| 跳过服务启动验证 | 集成问题无法发现 |
| 不读 tech-lead.md 就执行 | 缺少详细操作步骤 |
| **开发中生成测试** | 测试应在开发前由 /test-gen 生成 |
| **测试之前写代码** | 删掉代码，重新开始 |

---

## ✅ 完成提示

```
✅ 计划执行完成

📊 执行统计:
- 执行模式: 多人协作模式
- 并行开发者: Alice, Bob, Charlie
- 效率提升: 2-5 倍

📋 开发者完成情况:
- Alice (登录功能): ✅ TDD 通过, 验证通过
- Bob (注册功能): ✅ TDD 通过, 验证通过
- Charlie (密码重置): ✅ TDD 通过, 验证通过

🔧 Tech Lead 集成验证:
- 服务启动: ✅ 健康检查通过

下一步: /check（开发检查）
```
