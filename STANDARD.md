# Skills 标准索引

> 所有可用的 Skills 列表，按工作流程阶段组织
> **版本**：v3.2（智能流程选择，2026-02-01）

## 核心理念

| 理念 | 说明 |
|------|------|
| **简单、合适、演化** | 不过度设计，根据需求规模选择合适的流程 |
| **多人协作** | 按功能拆分，Alice/Bob/Charlie 并行开发，效率提升 **2-5 倍** |
| **严格 TDD** | 没有先失败的测试，就没有生产代码 |
| **完成前验证** | 只有亲眼看到验证命令成功，才能声称完成 |
| **服务启动验证** | 必须亲眼看到服务正常启动并响应请求 |

## 规范文件说明

| 目录 | 加载方式 | 内容 |
|------|---------|------|
| `~/.claude/rules/` | **始终加载** | 核心铁律（RULES.md） |
| `~/.claude/reference/` | **按需加载** | 详细规范（由 Skills 触发读取） |

### 核心参考规范

| 规范 | 路径 | 用途 |
|------|------|------|
| TDD 规范 | `~/.claude/reference/TDD规范.md` | 严格的测试驱动开发 |
| 完成前验证 | `~/.claude/reference/完成前验证.md` | 声明完成前的验证清单 |
| 并行拆分策略 | `~/.claude/reference/并行拆分策略.md` | 多人协作模式的拆分原则 |

---

## 🎯 流程选择指南（核心）

> **原则**：根据需求规模智能选择流程，遵循"简单、合适、演化"

### 需求规模判断

| 规模 | 判断条件 | 示例 |
|------|---------|------|
| **小** | AC ≤ 3，模块 ≤ 2 | 修复 bug、添加字段、调整样式 |
| **中** | AC ≤ 8，模块 ≤ 5 | 新增 API、添加页面、功能增强 |
| **大** | AC > 8 或 模块 > 5 | 新增子系统、重构核心模块 |

### 推荐流程

| 规模 | 推荐流程 | 跳过环节 |
|------|---------|---------|
| **小** | clarify → plan → run-plan → check → ship | explore、design、critique |
| **中** | clarify → design → plan → run-plan → check → qa → ship | explore、critique（可选） |
| **大** | clarify → explore → design → plan → run-plan → check → qa → ship | critique（可选） |

### 快速入口

| 场景 | 命令 | 说明 |
|------|------|------|
| **一键开发** | `/auto-dev` | 智能判断规模，自动选择流程 |
| **需求阶段自动化** | `/req-loop` | clarify + 外部评审，输出经审 AC 文档 |
| **设计阶段自动化** | `/design-loop` | explore + design + 双重评审 + 自动修复 |
| **开发阶段自动化** | `/dev-loop` | run-plan + check + 自动修复 |
| 小改动 | 直接开发 → `/check` → `/ship` | 不需要走流程 |
| 调试问题 | `/debug` → 修复 → `/check` → `/ship` | 专注问题解决 |

---

## 快速选择

| 你想做什么？ | 命令 | 说明 |
|-------------|------|------|
| **🚀 自动开发** | `/auto-dev` | 需求→成品全自动，**多人协作 + 严格 TDD**，效率提升 2-5 倍 |
| **项目概览** | `/overview` | 接手新项目时快速理解全貌（产品视角+架构图） |
| **需求循环** | `/req-loop` | clarify → gemini-critique，评审有问题时提示用户补充 |
| **设计循环** | `/design-loop` | explore → design → 双重评审，失败自动修复（最多 2 次） |
| 需求澄清 | `/clarify` | 上下文感知的精准澄清，先研究项目再提问 |
| 方案探索 | `/explore` | 调研业界最佳实践（至少5个来源） |
| **架构设计** | `/design` | 模块划分、接口契约、数据模型 |
| 产品设计 | `/product` | 心理学视角的 PRD/交互设计 |
| **代码重构** | `/refactor` | 通用入口，自动识别语言并应用对应规则 |
| 重构 Java | `/refactor-java` | Java/Spring 过度设计：God Class、接口泛滥 |
| 重构 Python | `/refactor-py` | Python/FastAPI 过度设计：ABC 滥用、装饰器嵌套 |
| 写实施计划 | `/plan` | 支持**多人协作模式** + **验收测试场景**（Given-When-Then） |
| **执行计划** | `/run-plan` | **多人协作执行**，Alice/Bob/Charlie 并行开发 |
| **开发循环** | `/dev-loop` | 自动执行 run-plan → check，失败自动修复重试 |
| **开发检查** | `/check` | 6 Agent 并行检查，含**服务启动验证** |
| **测试验收** | `/qa` | 基于 /plan 验收场景执行，金字塔门控（单元→集成→E2E） |
| 调试问题 | `/debug` | 四阶段根因分析 |
| 并行调查 | `/parallel` | 多 agent 并行处理 |
| Agent 编排 | `/experts` | 多专家协调 |
| 隔离开发 | `/worktree` | Git Worktree 管理 |
| 创建技能 | `/new-skill` | TDD 方法创建新技能 |
| MCP 开发 | `/mcp-builder` | MCP 服务器开发指南 |
| Admin UI | `/admin-ui` | Ant Design 后台管理 UI 规范 |
| H5 移动端 | `/h5` | 移动端交互体验优化 |
| **安全扫描** | `/security` | 专业工具扫描 OWASP Top 10 漏洞 |
| **性能分析** | `/perf` | 定位热点函数和 N+1 查询 |
| **测试生成** | `/test-gen` | 生成 FAILING 测试，支持从验收场景生成（AC 模式） |
| 代码扫描 | `/scan` | 代码质量扫描（技术债） |
| **代码交付** | `/ship` | 提交、推送、创建 PR 一键完成 |

---

## 主工作流（智能流程选择）

```
/overview（项目概览）← 接手新项目时首先使用
    ↓
/clarify（需求澄清）← 必须，定义 AC
    ↓
【智能判断需求规模】
    ↓
    ├─ 小需求（AC ≤ 3）
    │   → /plan → /run-plan → /check → /ship
    │
    ├─ 中需求（AC ≤ 8）
    │   → /design → /plan → /run-plan → /check → /qa → /ship
    │
    └─ 大需求（AC > 8）
        → /explore → /design → /plan → /run-plan → /check → /qa → /ship
```

**关键变化（v3.2）**：
- `/explore`、`/design`：根据需求规模**按需调用**，不再强制
- `/critique`：从"自动触发"改为**可选**，默认跳过
- `/auto-dev`：智能判断规模，自动选择流程

**核心改进（v3.2）**：
- **智能流程选择**：根据需求规模自动决定走哪些环节
- `/explore`、`/design`：按需调用，小需求跳过
- `/critique`：从"自动触发"改为"可选"，默认跳过，守门而非扩展
- `/auto-dev`：智能判断规模，自动选择流程

**可选分支**：
- `/product`：涉及用户体验时，在 `/clarify` 之后使用
- `/refactor`：代码重构时，替代 `/explore` → `/design` → `/plan` 流程
- **`/auto-dev`**：自动循环开发，融合多人协作 + 严格 TDD + 智能流程选择
- `/critique`：大需求或安全敏感时，可通过 `--with-critique` 启用

### 🚀 自动开发流程（往死里干模式）

```
/clarify（需求澄清）← 手动，确认需求
    ↓
/auto-dev（自动循环开发 v2.0）← 全自动，可过夜运行
    ├─ 内含: /explore → /design → /plan v3.0
    ├─ 内含: 多人协作执行（Alice/Bob/Charlie 并行）
    ├─ 内含: 严格 TDD + 完成前验证
    ├─ 内含: 服务启动验证
    └─ 内含: /check v3.0（6 Agent 并行）
    ↓
/qa（测试验收）← 手动，最终验收
    ↓
/ship（代码交付）← 手动，提交代码
```

**效率提升**：相比串行执行，提升 **2-5 倍**

---

## Skills 详情

### 🚀 auto-dev（自动开发 - 往死里干模式）

**触发**：`/auto-dev`

**用途**：输入需求文档，自动执行完整开发链路，循环迭代直到可交付

**版本**：v2.0（往死里干模式，2025-01-28）

**核心原理**：
- **多人协作模式**：按功能分派 Alice/Bob/Charlie 并行开发
- **严格 TDD**：没有先失败的测试，就没有生产代码
- **完成前验证**：亲眼看到验证命令成功
- **服务启动验证**：亲眼看到服务正常运行

**效率提升**：相比串行执行，提升 **2-5 倍**

**使用方式**：
```bash
# 交互式
/auto-dev

# 直接启动
/auto-dev docs/需求文档/PRD_xxx.md --max-iterations 30

# 命令行（过夜运行）
~/.claude/skills/自动开发_auto-dev/scripts/auto-dev.sh --prd docs/PRD.md --max-iterations 50
```

**适用场景**：
- ✅ 需求清晰的新功能
- ✅ 独立模块开发
- ✅ 多功能并行（效率最大化）
- ✅ 过夜运行
- ❌ 需求模糊（先用 /clarify）
- ❌ 复杂重构（用 /refactor）

**安全机制**：
- 迭代上限（默认 30 次）
- 中断恢复（--resume）
- 详细日志（.claude/auto-dev-detail.md）

---

### 0. overview（项目概览）

**触发**：`/overview`

**用途**：接手新项目时快速理解全貌，建立认知地图

**版本**：v1.0（2025-01-26）

**核心原则**：
- **用产品视角理解代码**：不是看懂每一行，而是理解解决什么问题
- **用架构视角建立地图**：核心模块如何协作
- **给出入门指南**：新手应该从哪里开始

**输出**：
- 用通俗语言解释项目用途
- 核心模块关系图（Mermaid）
- 推荐先看的 3 个文件
- 保存到 `docs/项目概览.md`

**支持的项目类型**：
- Java/Spring 后端
- Vue/React 前端
- UniApp H5/小程序
- Python/FastAPI 后端

---

### 1. clarify（需求澄清）

**触发**：`/clarify`

**用途**：基于项目上下文的精准需求澄清，充分利用项目规范和代码信息，减少无效提问

**版本**：v2.0（上下文感知版，2025-01-22 更新）

**核心原则**：
- **先研究，再提问**：充分利用项目规范、代码、文档
- **聚焦关键疑点**：只问真正不确定的问题
- **结合项目约束**：基于规范主动告知约束，不问已知
- 一次只问一个核心问题
- 优先使用选择题（基于实际情况）

**执行流程**：
0. **项目上下文研究**（核心改进）：读取规范、读取代码、识别约束
1. 总结当前状态（展示给用户）
2. 聚焦关键疑点（问题分类：规范相关/技术实现/业务逻辑）
3. 精准提问（基于项目的具体选项）
4. 确认边界和约束（引用项目规范）
5. 输出增强版需求文档（含上下文和技术方案要点）

**改进效果**：提问轮次从 5 轮降到 2-3 轮，用户感受到「被理解」

---

### 2. explore（方案探索）

**触发**：`/explore`

**用途**：调研业界最佳实践，选择最优方案

**核心原则**：
- **至少调研 5 个来源**（GitHub、官方文档、技术博客等）
- 提供 2-3 个可行方案对比
- 分段验证，每段确认后再继续
- 遵循 YAGNI 原则

**输出**：调研对比表 + 推荐方案

**不做的事情**（交给 `/design`）：
- 模块划分
- 接口设计
- 数据模型设计

---

### 3. design（架构设计）

**触发**：`/design`

**用途**：将技术方案转化为可落地的系统蓝图

**核心产出**：
- 模块划分（边界、职责、依赖）
- 接口设计（API 路径、参数、响应、错误码）
- 数据模型（表结构、索引、关联关系）

**前置条件**：有 `/explore` 的输出（推荐方案）

**输出**：架构设计文档 → `docs/设计文档/设计_[主题].md`

---

### 4. product（产品设计）

**触发**：`/product`，或讨论用户行为、功能设计时自动激活

**用途**：基于心理学的产品设计分析

**核心框架**：
- 认知心理学（7±2 法则、希克定律）
- 行为心理学（Fogg 模型、Hooked 模型）
- 情绪设计（三层设计、峰终定律）
- 尼尔森十大可用性原则

---

### 5. plan（写计划 v3.0）

**触发**：`/plan`

**用途**：将架构蓝图转化为可执行的步骤清单，**支持多人协作模式**

**版本**：v3.0（多人协作模式，2025-01-28）

**核心改进**：
- **多人协作模式**：按功能拆分，分派开发者（Alice/Bob/Charlie）
- **文件范围指定**：每个开发者明确负责的文件，避免冲突
- **Tech Lead 工作**：基础设施（前置）+ 集成验证（后置）

**拆分模式选择**：

| 模式 | 适用场景 | 效率提升 |
|------|---------|---------|
| 多人协作模式 | 功能独立、文件不冲突 | **2-5 倍** |
| 依赖链模式 | 强耦合、必须串行 | 40-60% |

**前置条件**：有 `/design` 的输出（架构设计）

**输出**：计划文档 → `docs/开发文档/plan_[功能名].md`

---

### 6. refactor（代码重构 - 通用入口）

**触发**：`/refactor`

**用途**：通用重构入口，自动识别语言并应用对应的重构规则

**语言路由**：
- Java 代码 → 自动应用 `/refactor-java` 规则
- Python 代码 → 自动应用 `/refactor-py` 规则

**三大原则**：
1. **简单**：不过度设计，避免"万一将来需要"的预设
2. **合适**：该复杂时复杂（业务本身复杂），该简单时简单
3. **演化**：根据实际需求演化，重复 3 次再抽象

**重构方向**：
- **减法**：过度设计 → 删除不必要的抽象（如只有一个实现的接口）
- **加法**：设计不足 → 补充必要的抽象（如有多个实现需要切换时保留接口）
- **调整**：设计不当 → 重新划分职责

---

### 6a. refactor-java（Java 代码重构）

**触发**：`/refactor-java`

**用途**：处理 Java/Spring 项目的代码质量问题

**核心关注**：
- **God Class**：>1000 行，>10 依赖 → 按职责拆分
- **接口泛滥**：只有一个实现的接口 → 删除接口
- **依赖爆炸**：>10 个 @Autowired → 拆分类
- **假设计模式**：Factory/Strategy 只有一个实现 → 删除

**Spring 特定规则**：
- 透传 Service 层 → 合并或删除
- DTO 爆炸 → 复用或直接用 Entity

---

### 6b. refactor-py（Python 代码重构）

**触发**：`/refactor-py`

**用途**：处理 Python/FastAPI 项目的代码质量问题

**核心关注**：
- **ABC 滥用**：只有一个实现的抽象类 → 删除 ABC
- **装饰器嵌套**：3 层以上 → 合并装饰器
- **过度继承**：继承链 >3 层 → 用组合替代
- **过度 DI**：模仿 Spring IoC → 直接导入

**FastAPI 特定规则**：
- 过度 Depends → 只注入必要依赖
- 每个端点一个文件 → 按资源分组

---

### 7. run-plan（执行计划 v3.0）

**触发**：`/run-plan`

**用途**：执行详细计划，**支持多人协作模式，效率提升 2-5 倍**

> 💡 **提示**：如需自动化完整开发阶段（run-plan → check + 自动修复），使用 `/dev-loop`

**版本**：v3.0（多人协作模式，2025-01-28）

**核心改进**：
- **多人协作模式**：Alice/Bob/Charlie 并行开发独立功能
- **角色设定**：Tech Lead（基础设施+集成）+ 开发者（独立功能）
- **文件边界约束**：每个开发者只修改分配的文件
- **严格 TDD**：引用 `~/.claude/reference/TDD规范.md`
- **完成前验证**：引用 `~/.claude/reference/完成前验证.md`
- **服务启动验证**：Tech Lead 后置工作必须验证

**执行流程**：
```
Tech Lead 前置工作（基础设施）
    ↓
Alice/Bob/Charlie 并行执行（严格 TDD）
    ↓
Tech Lead 后置工作（集成 + 服务启动验证）
```

**前置条件**：必须有符合规范的计划文档（v3.0 格式推荐）

---

### 7b. dev-loop（开发循环）

**触发**：`/dev-loop`

**用途**：自动化开发阶段，执行 run-plan → check 完整循环

**版本**：v1.0（2026-02-04）

**核心机制**：
- **状态机驱动**：9 种状态，明确的转换规则
- **分层自动修复**：L1 Lint → L2 类型 → L3 测试
- **检查点恢复**：中断后可从上次状态恢复
- **最大重试 3 次**：check 失败重试计数

**执行流程**：
```
门控检查（plan 存在？）
    ↓
/run-plan
    ↓
/check ←─┐
    │    │ 失败：自动修复（最多 3 次）
    ↓    │
成功报告 / 失败报告
```

**与 /auto-dev 的区别**：
| 维度 | /dev-loop | /auto-dev |
|------|-----------|-----------|
| 范围 | 开发阶段（run-plan → qa 之前） | 全流程（clarify → qa） |
| 输入 | plan 文档 | 需求文档或 plan 文档 |
| 设计阶段 | 不包含 | 包含（智能判断） |

**前置条件**：plan 文档必须存在

---

### 8. check（开发检查 v3.0）

**触发**：`/check`

**用途**：开发完成后的一站式自检，**6 Agent 并行执行**

**版本**：v3.0（新增服务启动验证，2025-01-28）

**核心改进**：
- **Agent6 服务启动验证**：必须亲眼看到服务正常启动并响应请求
- 引用 `~/.claude/reference/完成前验证.md`

**6 Agent 并行检查**：
1. Agent1: 铁律检查（禁止降级、禁止硬编码、禁止Mock）
2. Agent2: 后端自动化（ruff、mypy、pytest）
3. Agent3: 前端自动化（lint、type-check、build）
4. Agent4: 代码质量审查（安全、性能）
5. Agent5: 文档同步检查
6. **Agent6: 服务启动验证**（铁律：亲眼看到服务正常运行）

**检查不通过**：列出问题和修复建议，修复后重新执行 `/check`

---

### 9. qa（测试验收）

**触发**：`/qa`

**用途**：独立于开发的测试专家角色，运用专业测试方法，为最终交付质量负责

**版本**：v2.0（专业测试方法论版，2025-01-23 更新）

**核心改进**：
- 引入 ISTQB 测试设计方法（等价类、边界值、决策表、状态转换）
- 测试金字塔指导（70% 单元 / 20% 集成 / 10% E2E）
- pytest 自动化集成
- 基础安全/性能测试检查

**测试设计方法**：
| 方法 | 适用场景 |
|------|---------|
| 等价类划分 | 输入有明确范围 |
| 边界值分析 | 有数值边界 |
| 决策表 | 复杂业务规则 |
| 状态转换 | 有状态流转 |
| 错误猜测 | 经验驱动 |

**流程**：
1. 测试前审问
2. 环境检查
3. **测试用例设计（专业方法）**
4. 执行测试（自动化 + 手动）
5. 生成测试报告 + 质量签字

---

### 10. debug（系统化调试）

**触发**：`/debug`

**用途**：四阶段根因分析，避免盲目猜测

**核心原则**："没有根因调查，就没有修复"

**四阶段**：
1. 根因调查（必须先完成）
2. 模式分析
3. 假设验证
4. 实施修复

---

### 11. parallel（并行 Agent）

**触发**：`/parallel`

**用途**：多个独立问题并行调查

**适用场景**：
- 多文件测试失败
- 多子系统问题
- 独立调查任务

**优势**：3 倍以上的速度提升

---

### 12. experts（Agent 编排）

**触发**：`/experts`

**用途**：多专家 Agent 协调复杂任务

**可用专家**：
- tech-lead：项目全局、任务分解、协调整合
- backend-architect：Python/FastAPI、API、数据库
- frontend-architect：React/TypeScript、交互设计
- security-auditor：安全漏洞、合规性
- code-reviewer：代码质量、最佳实践

**适用场景**：涉及前后端的全栈任务、架构设计、安全审计

---

### 13. worktree（Git Worktree）

**触发**：`/worktree`

**用途**：为开发任务创建隔离的工作目录

**优势**：
- 不影响主分支
- 并行开发多个功能
- 无需 stash 半成品代码

---

### 14. new-skill（技能创作）

**触发**：`/new-skill`

**用途**：用 TDD 方法创建和验证新的 Skills

**核心理念**：TDD 不只适用于代码，也适用于技能/文档

**流程**：
1. 识别需求（AI 经常犯什么错？）
2. 设计压力测试（会让 AI 犯错的场景）
3. 运行 RED 测试（验证 AI 确实违反）
4. 编写 SKILL.md
5. 运行 GREEN 测试（验证 AI 遵守）
6. 迭代完善

---

### 15. mcp-builder（MCP 开发）

**触发**：`/mcp-builder`

**用途**：构建高质量的 Model Context Protocol 服务器

**来源**：anthropics/skills（Anthropic 官方）

---

### 16. admin-ui（Admin 后台 UI）

**触发**：`/admin-ui`，或开发后台管理页面、使用 Ant Design 组件时自动激活

**用途**：Admin 后台管理系统 UI 开发规范

**技术栈**：
- 框架：React 18+ + TypeScript
- UI 组件：Ant Design 5.x
- 请求：ahooks (useRequest)
- 路由：react-router-dom v6

**核心内容**：
- 页面布局规范
- 表格规范
- 表单规范
- 弹窗规范
- 状态与反馈
- 权限控制 UI 模式

---

### 17. h5（H5 移动端开发）

**触发**：`/h5`，或开发 H5 组件、讨论移动端交互时自动激活

**用途**：移动端开发规范（UniApp + Vue3）

**核心关注**：
- 60fps 流畅动画
- 即时触摸反馈（< 100ms）
- 容错友好的错误提示
- 响应式布局

---

### 18. security（安全扫描）

**触发**：`/security`

**用途**：使用专业工具检测安全漏洞，覆盖 OWASP Top 10

**版本**：v1.2（2026-01-28）

**核心工具**：
- **SAST**: Bandit (Python) + Semgrep (多语言)
- **密钥扫描**: Gitleaks
- **依赖漏洞**: pip-audit / npm audit
- **容器安全**: Trivy

**执行模式**：
| 模式 | 说明 |
|------|------|
| `/security` | 默认完整扫描 |
| `/security quick` | 快速扫描 (<30s) |
| `/security full` | 全面扫描 + AI 审查 |
| `/security deps` | 仅依赖漏洞 |
| `/security docker` | 容器镜像扫描 |
| `/security fix` | 扫描 + 自动修复 |

**输出**：
- 终端摘要（严重/高危/中危/低危）
- 完整报告 → `docs/安全扫描/[日期]_安全扫描报告.md`
- 每个漏洞附可执行修复代码

**铁律**：工具优先、修复完整、不隐瞒严重漏洞

---

### 19. perf（性能分析）

**触发**：`/perf`

**用途**：使用专业工具定位性能瓶颈，输出火焰图和优化建议

**版本**：v1.2（2026-01-28）

**核心工具**：
- **CPU 热点**: pyinstrument / py-spy / scalene
- **N+1 检测**: nplusone / fastapi-sqlalchemy-monitor
- **内存分析**: memory_profiler / tracemalloc

**执行模式**：
| 模式 | 说明 |
|------|------|
| `/perf` | 默认 pyinstrument 分析 |
| `/perf quick` | 热点 Top 10 (<30s) |
| `/perf deep` | scalene 全面分析 |
| `/perf n1` | N+1 查询检测 |
| `/perf memory` | 内存分析 |
| `/perf attach <pid>` | 附加运行中进程 |
| `/perf flame` | 生成火焰图 |

**输出**：
- 终端摘要（热点 Top 5 + N+1 问题）
- HTML 报告 → `docs/性能分析/[日期]_性能分析报告.html`
- 火焰图 → `docs/性能分析/[日期]_flame.svg`

**铁律**：数据驱动（禁止猜测）、可视化、可量化、可操作

---

### 20. test-gen（测试生成）

**触发**：`/test-gen`

**用途**：生成高质量的 FAILING 测试，作为 TDD 的起点

**版本**：v1.0（2026-01-28）

**核心原则**：
- **TDD 优先**：生成失败的测试，驱动正确实现
- **覆盖率 80%**：工程甜点，关键路径 90%+
- **禁止过度 Mock**：数据库必须真实连接

**执行模式**：
| 模式 | 说明 |
|------|------|
| `/test-gen` | 默认：分析 + 生成 FAILING 测试 |
| `/test-gen quick <fn>` | 快速：单函数测试 |
| `/test-gen property <fn>` | 属性：Hypothesis/fast-check |
| `/test-gen boundary <fn>` | 边界：边界值分析 |
| `/test-gen spec <api>` | 规范：从 OpenAPI 生成 |
| `/test-gen verify` | 验证：检查测试质量 |

**测试策略推荐**：
| 函数类型 | 推荐方法 | 覆盖目标 |
|---------|---------|---------|
| 支付/认证 | TDD + 属性测试 | 90%+ |
| 验证逻辑 | 边界值 + 等价类 | 80% |
| 算法 | 属性测试 | 80% |
| API 端点 | 规范驱动 | 75% |

**输出**：
- FAILING 测试文件 → `tests/test_xxx.py`
- 属性测试（如适用）→ `tests/test_xxx_property.py`
- 覆盖率估算 + 下一步建议

**铁律**：禁止 Mock 数据库、TDD 优先、质量 > 数量

---

### 21. scan（代码扫描）

**触发**：`/scan [项目路径]`

**用途**：扫描项目整体代码质量，发现存量技术债

**版本**：v1.0（2025-01-26）

**与 /check 的区别**：
| 维度 | /check | /scan |
|------|--------|-------|
| 范围 | 变更文件（git diff） | 全项目 |
| 时机 | 开发完成后 | 定期巡检、接手项目 |
| 输出 | 通过/不通过 | 健康度评分 + 详细报告 |

**检测内容**：
- 铁律检测（降级/硬编码/Mock）
- 安全漏洞（SQL 注入/XSS）
- 代码规范（函数长度/空 catch）
- 技术债（TODO/FIXME/废弃代码）

**输出**：
- 健康度评分 (0-100)
- 详细报告 → `docs/技术债扫描/[日期]_技术债扫描报告.md`

---

### 22. ship（代码交付）

**触发**：`/ship`

**用途**：一键完成代码提交、推送和 PR 创建

**核心流程**：
1. 检查 git 状态
2. 分析变更内容
3. 自动生成 commit message（用户确认）
4. 提交代码
5. 推送远程
6. 创建 PR（可选）

**安全特性**：
- 敏感文件检测（.env、credentials 等）
- 推送前确认
- 禁止 force push

**前置条件**：`/check` 或 `/qa` 通过后使用

---

## 典型工作流

### 小改动
```
直接开发 → /check → /ship
```

### 中等功能
```
/clarify → /explore → /design → /plan → /run-plan → /check → /qa → /ship
```

### 大型功能
```
/experts → /clarify → /explore → /design → /plan
→ /worktree → /run-plan → /check → /qa → /ship
```

### 调试问题
```
/debug → 修复 → /check → /ship
```

### 代码重构
```
/refactor → 输出重构计划 → /run-plan → /check → /qa → /ship
```

### 多问题并行
```
/parallel → （各 agent 执行 /debug）→ /check → /ship
```

### 创建新技能
```
/new-skill → 识别需求 → RED 测试 → 编写 SKILL.md → GREEN 测试 → 迭代完善
```
