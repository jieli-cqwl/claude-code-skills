---
name: refactor
command: refactor
user_invocable: true
parallel_mode: true
description: 代码重构。遵循简单、合适、演化原则，让代码保持最佳状态。自动识别语言并应用对应的重构规则。
---

# 代码重构 (Refactor)

> **角色**：代码质量守护者
> **目标**：让代码保持"恰到好处"的状态
> **原则**：简单、合适、演化
> **思考模式**：启用 ultrathink 深度思考，全面评估重构影响范围

---

## 触发条件

当用户使用以下任一方式时，立即激活此 skill：
- 说"**重构**"或"**代码重构**"（主触发词）
- 使用命令：`/refactor`
- 说"代码太乱了"、"需要整理"
- 说"优化代码结构"
- 说"过度设计了"

**适用场景**：
- 代码需要整理和优化
- 发现过度设计
- 提升代码可维护性

---

## 核心理念

**"重构不是简化，而是让代码恰到好处"**

| 误区 | 正确理解 |
|------|---------|
| 代码越少越好 | 代码量要**合适** |
| 抽象越少越好 | 抽象要**恰当** |
| 简单就是好 | **必要的复杂**也是好的 |

---

## 三大原则

### 1. 简单原则

**不过度设计**

| 检查 | 行动 |
|------|------|
| 只有一个实现的接口 | 删除接口 |
| "万一将来需要"的代码 | 删除（YAGNI） |
| 只是透传的中间层 | 合并层 |

### 2. 合适原则

**该复杂时复杂，该简单时简单**

| 场景 | 正确做法 |
|------|---------|
| 业务本身复杂 | 保持必要的复杂度 |
| 有多个实现需要切换 | 保留接口抽象 |
| 有真实的扩展需求 | 保留扩展点 |

### 3. 演化原则

**根据实际需求演化，而非预设**

| 误区 | 正确做法 |
|------|---------|
| 预先设计所有扩展点 | 需要时再加 |
| 一开始就分层完整 | 逐步演化分层 |
| 提前抽象公共模块 | 重复 3 次再抽象 |

---

## 重构方向

重构不只是"减法"，可能是：

| 方向 | 场景 | 行动 |
|------|------|------|
| **减法** | 过度设计 | 删除不必要的抽象 |
| **加法** | 设计不足 | 补充必要的抽象 |
| **调整** | 设计不当 | 重新划分职责 |

---

## 语言识别与路由

根据代码语言，自动应用对应的重构规则：

| 语言 | 专属 Skill | 核心关注 |
|------|-----------|---------|
| **Java** | `/refactor-java` | God Class、接口泛滥、Spring 分层 |
| **Python** | `/refactor-py` | ABC 滥用、装饰器嵌套、过度 OOP |

**自动识别规则**：
- 看到 `.java` 文件 → 应用 Java 规则
- 看到 `.py` 文件 → 应用 Python 规则
- 用户可直接指定：`/refactor-java` 或 `/refactor-py`

---

## 并行架构

本 Skill 采用 **10 Agent 并行检测 + 10 Agent 并行建议** 架构，大幅提升重构分析效率。

```
Phase 1: 并行检测（10 Agent）
    ↓ 等待所有 Agent 完成
Phase 2: 并行重构建议（10 Agent）
    ↓ 等待所有 Agent 完成
Phase 3: 汇总计划（串行）
    ↓
交给 /run-plan 执行
```

---

### Phase 1: 并行检测（10 Agent，subagent_type=Explore）

同时启动以下 10 个代码坏味道检测任务：

| Agent | 检测任务 | 检测内容 |
|-------|---------|---------|
| Agent 1 | God Class 检测 | 职责过多的类（>10 方法，>5 依赖） |
| Agent 2 | 长方法检测 | 超过 50 行或圈复杂度 >10 的方法 |
| Agent 3 | 重复代码检测 | 相似代码块、复制粘贴痕迹 |
| Agent 4 | 过度耦合检测 | 类间依赖过多、循环依赖 |
| Agent 5 | 接口膨胀检测 | 只有单一实现的接口、过度抽象 |
| Agent 6 | 魔法数字检测 | 硬编码常量、未命名的数值 |
| Agent 7 | 死代码检测 | 未使用的方法、类、变量 |
| Agent 8 | 命名规范检测 | 不规范命名、缩写滥用 |
| Agent 9 | 复杂度分析 | 嵌套过深、条件分支过多 |
| Agent 10 | 依赖循环检测 | 模块间循环依赖、分层违规 |

**执行规则**：
- 每个 Agent 独立扫描指定范围的代码
- 输出标准化的问题报告（位置、严重程度、描述）
- **等待所有 Agent 完成后继续**

---

### Phase 2: 并行重构建议（10 Agent，subagent_type=general-purpose）

根据 Phase 1 检测到的问题，各 Agent 生成对应的重构方案：

| Agent | 对应问题 | 重构建议方向 |
|-------|---------|-------------|
| Agent 1 | God Class | 拆分类、提取职责 |
| Agent 2 | 长方法 | 提取方法、简化逻辑 |
| Agent 3 | 重复代码 | 提取公共方法/模块 |
| Agent 4 | 过度耦合 | 解耦、引入中间层 |
| Agent 5 | 接口膨胀 | 删除冗余接口、合并抽象 |
| Agent 6 | 魔法数字 | 提取常量、使用枚举 |
| Agent 7 | 死代码 | 安全删除、清理引用 |
| Agent 8 | 命名规范 | 重命名建议、统一风格 |
| Agent 9 | 复杂度过高 | 简化条件、提取子函数 |
| Agent 10 | 依赖循环 | 调整依赖方向、分层重构 |

**执行规则**：
- 每个 Agent 针对检测到的具体问题生成重构步骤
- 评估重构影响范围和风险
- **等待所有 Agent 完成后继续**

---

### Phase 3: 汇总计划（串行）

主 Agent 整合所有重构建议，输出统一的重构计划：

**汇总步骤**：
1. 收集所有 Agent 的检测结果和重构建议
2. 按优先级排序（高风险优先、依赖关系排序）
3. 合并相关的重构任务（避免重复）
4. 生成可执行的重构计划文档

**输出到** `docs/开发文档/plan_重构_[模块名].md`

---

## 错误处理

### Agent 失败处理

| 场景 | 处理方式 |
|------|---------|
| 单个 Agent 超时 | 记录超时，使用已完成 Agent 的结果继续 |
| 单个 Agent 报错 | 记录错误，跳过该检测项，不阻塞整体流程 |
| 多数 Agent 失败（>5个） | 终止并行，切换为串行模式执行 |
| 全部 Agent 失败 | 报告错误，要求用户检查代码路径和权限 |

### 结果校验

| 校验项 | 失败处理 |
|--------|---------|
| 检测结果为空 | 提示用户确认代码范围是否正确 |
| 建议相互冲突 | 主 Agent 在 Phase 3 中人工裁决 |
| 输出格式异常 | 尝试解析，失败则忽略该 Agent 结果 |

---

## 传统执行流程（参考）

> 以下为非并行模式的传统流程，供参考理解重构逻辑。

### 代码诊断指标

**通用指标**：

| 层级 | 核心指标 | 警戒阈值 |
|------|---------|---------|
| **文件级** | 代码行数 | >300 行（可能需要拆分） |
| **类级** | 方法数、依赖数 | >10 方法，>5 依赖 |
| **函数级** | 行数、圈复杂度 | >50 行，>10 复杂度 |

---

### 问题识别

| 问题类型 | 特征 | 方向 |
|---------|------|------|
| **过度设计** | 抽象多但实现少、层级多但只透传、只有一个实现的接口 | 减法 |
| **设计不足** | 职责混乱、重复代码多、难以扩展 | 加法 |
| **设计不当** | 边界划分不清、依赖方向错误 | 调整 |

---

## 危险信号

| 信号 | 行动 |
|------|------|
| 重构后代码更难理解 | 停，方向可能错了 |
| 重构引入新的复杂度而无收益 | 停，重新评估 |
| 重构破坏了现有功能 | 停，先写测试保护 |
| 没有明确目标就开始重构 | 停，先诊断 |

---

## 与其他 Skills 的关系

```
发现代码问题 / 准备优化
    ↓
/refactor（重构）← 当前（自动路由到语言专属 skill）
    ↓ 输出重构计划
/run-plan（执行计划）
    ↓
/check（开发检查）
    ↓
/qa（测试验收）
```

---

## 完成检查清单

- [ ] 代码诊断完成，问题类型明确
- [ ] 重构方向确定（减法/加法/调整）
- [ ] 重构计划输出，每步可验证
- [ ] 符合三原则（简单、合适、演化）
- [ ] 计划文档已保存到 `docs/开发文档/`
