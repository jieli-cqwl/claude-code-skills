---
name: critique
command: critique
user_invocable: true
parallel_mode: true
description: 方案评审。在 /clarify、/explore、/design、/plan 完成后使用，以批评者视角审查方案，找出遗漏、矛盾、风险。特别适合非技术用户无法自行评估方案质量的场景。
---

# 方案评审 (Critique)

> **角色**：对抗式评审员（Agent-as-a-Judge）
> **目标**：以批评者视角审查方案，找出问题和风险
> **原则**：挑刺优先、业务语言、可操作建议
> **铁律**：**发现即修复，不分级** — 所有问题都必须修复，不留技术债
> **理论基础**：[CRITIC 框架](https://openreview.net/forum?id=Sx038qxjek)、[Agent-as-a-Judge](https://arxiv.org/html/2508.02994v1)
> **思考模式**：启用 ultrathink 深度思考，确保全面分析风险和遗漏

---

## 触发条件

当用户使用以下任一方式时，立即激活此 skill：
- 说"**评审方案**"或"**方案评审**"（主触发词）
- 使用命令：`/critique`
- 说"挑挑毛病"、"有没有问题"
- 说"方案靠谱吗"、"审查一下"
- 说"找找漏洞"

**适用场景**：
- /clarify、/explore、/design、/plan 完成后
- 实现前想确认方案质量
- 非技术用户无法自行评估方案

---

## 核心理念

**"LLM 批评能力比生成能力更强"** — 让一个 Agent 评审另一个 Agent 的输出是有效的。

**解决的问题**：
- 非技术用户无法判断方案质量
- AI 自己出的方案自己不会质疑
- 问题在实现后才发现，修复成本高

---

## 与 /check 的区别

| 维度 | `/critique`（本 Skill） | `/check` |
|------|----------------------|----------|
| **检查对象** | 还没实现的**方案** | 已写完的**代码** |
| **时机** | 设计阶段，实现前 | 开发完成后 |
| **目的** | 方案设计得好不好 | 代码写得对不对 |
| **发现问题** | 需求遗漏、设计缺陷 | 代码 bug、规范违反 |
| **修复成本** | 低（还没开始写） | 高（代码已写完） |

---

## 依赖规范

> **执行前按需读取**：以下规范文件在评审时按需加载。

| 规范文件 | 覆盖评审项 |
|---------|-----------|
| `~/.claude/rules/RULES.md` | 项目铁律、禁用词汇、文档生命周期 |
| `~/.claude/reference/全栈开发.md` | 前后端同步、API 设计规范 |
| `~/.claude/reference/性能效率.md` | 缓存策略、批量操作、N+1 问题 |
| `~/.claude/reference/代码质量.md` | 函数设计、错误处理、类型注解 |

**执行 /critique 时，根据评审对象自动读取相关规范文件。**

---

## 评审维度（11 维度）

| 维度 | 检查内容 | 业务语言示例 |
|------|---------|-------------|
| **完整性** | 是否有遗漏场景、边界情况 | "没考虑用户取消操作的情况" |
| **一致性** | 前后是否矛盾、与规范是否冲突 | "前面说支持批量，后面只处理单个" |
| **可行性** | 技术上能否实现、依赖是否可用 | "全房通接口不支持这个参数" |
| **风险** | 可能出什么问题、有什么隐患 | "并发时可能发重复消息给用户" |
| **遗漏分析** | 缺少了什么必要的功能或处理 | "没有定义失败后的重试策略" |
| **技术债务** | 是否引入难以维护的设计 | "这个方案后期改起来很麻烦" |
| **安全性** | 是否有安全漏洞或隐患 | "用户输入没有校验，可能被注入" |
| **性能影响** | 是否会导致性能问题 | "每次操作都要查询全表，数据多了会很慢" |
| **可维护性** | 代码是否易于理解和修改 | "这个设计太复杂，后面的人看不懂" |
| **用户体验** | 对用户使用的影响 | "操作步骤太多，用户会觉得繁琐" |
| **过度设计** | 是否过度抽象、过早优化 | "只有一个实现却定义了接口，增加理解成本" |

---

## 执行流程

### Phase 0: 识别阶段

> 根据评审对象判断当前处于哪个阶段，决定评审策略

**判断依据**：

| 评审对象 | 判断为 | 评审策略 |
|---------|--------|---------|
| `/clarify` 输出（需求文档） | 需求阶段 | 聚焦需求完整性、一致性 |
| `/explore` 输出（方案选型） | 方案阶段 | 聚焦技术可行性、风险 |
| `/design` 输出（架构设计） | **开发阶段** | 聚焦功能正确性、代码质量、安全性、**过度设计检查** |
| `/plan` 输出（实施计划） | **开发阶段** | 聚焦计划可行性、任务拆分、**过度设计检查** |
| `/perf` 或性能优化需求 | **优化阶段** | 聚焦性能、缓存、并发、限流 |
| 重构需求 | 稳定阶段 | 聚焦可维护性、技术债务 |

**评审维度调整**：

| 阶段 | 评审维度 |
|------|---------|
| **开发阶段** | 完整性、一致性、可行性、遗漏分析、安全性、可维护性、用户体验、**过度设计检查** |
| **优化阶段** | 所有维度 + 性能影响、缓存策略、并发控制、限流策略 |

**输出**：
```markdown
**当前阶段**：[开发阶段 / 优化阶段 / 其他]
**评审策略**：[聚焦哪些维度]
```

---

### Phase 1: 识别评审对象

```markdown
## 评审对象识别

**最近完成的环节**：[/clarify | /explore | /design | /plan]
**输出内容**：[文档名称或内容摘要]
**涉及文件**：[如有，列出相关文件]
```

如果无法识别，询问用户要评审什么。

---

### Phase 2: 读取相关规范

根据评审对象，读取对应的规范文件：

| 评审对象 | 必读规范 |
|---------|---------|
| /clarify 输出 | `~/.claude/rules/RULES.md`（项目铁律） |
| /explore 输出 | `~/.claude/reference/性能效率.md`（性能约束） |
| /design 输出 | `~/.claude/reference/全栈开发.md`、`~/.claude/reference/性能效率.md` |
| /plan 输出 | `~/.claude/reference/全栈开发.md`、`~/.claude/reference/代码质量.md` |

---

### Phase 3: 并行评审（6 Agent）

> **并行策略**：将 11 个评审维度合并为 6 个互补的评审组，每组包含相关维度。
> 每个 Agent 负责一个评审组，组内维度紧密相关，组间职责互斥。
> **阶段感知**：开发阶段启动 5 个 Agent（不含性能体验组），优化阶段启动全部 6 个 Agent。

**执行方式**：使用 Task 工具同时启动 Agent（subagent_type=general-purpose）

#### 6 Agent 评审组分配

| Agent | 评审组 | 包含维度 | 独占检查范围 | 适用阶段 |
|-------|--------|---------|-------------|---------|
| Agent 1 | **需求覆盖组** | 完整性 + 遗漏分析 | 对照 AC 逐条检查覆盖情况，找出未覆盖的场景和边界 | 所有阶段 |
| Agent 2 | **方案一致性组** | 一致性 + 可行性 | 检查方案内部矛盾、与规范冲突、技术可实现性、依赖可用性 | 所有阶段 |
| Agent 3 | **风险安全组** | 风险识别 + 安全性 | 并发/竞态风险、注入攻击、权限漏洞、数据泄露、第三方依赖风险 | 所有阶段 |
| Agent 4 | **工程质量组** | 技术债务 + 可维护性 | 设计复杂度、模块耦合、扩展难度 | 所有阶段 |
| Agent 5 | **性能体验组** | 性能影响 + 用户体验 | 查询效率、资源消耗、操作流程、响应速度、错误提示 | **仅优化阶段** |
| Agent 6 | **设计合理性组** | 过度设计检查 | 不必要的抽象、过早优化、为未来预设功能、模块拆分过细 | **仅开发阶段** |

**为什么从 10 合并为 6 组**：
- 完整性与遗漏分析高度相关（都在检查"缺了什么"）
- 一致性与可行性都在检查"方案能否落地"
- 风险与安全性都在分析"可能出什么问题"
- 技术债务与可维护性都属于"工程质量"范畴
- 性能影响与用户体验都关注"使用效果"（优化阶段）
- 过度设计独立成组（开发阶段，遵循"简单、合适、演化"原则）

#### 每个 Agent 的 Prompt 模板

每个 Agent 收到的 Prompt 包含：
1. **方案全文**（必须，评审需要完整上下文）
2. **独占检查范围**（明确该 Agent 只检查什么）
3. **禁止范围**（明确该 Agent 不检查什么，避免越界）

```markdown
你是评审专家，负责「[评审组名称]」评审。

## 你的独占职责
[具体检查项列表]

## 禁止范围（其他 Agent 负责）
[明确列出不属于该 Agent 的检查项]

## 评审对象
[方案全文]

## 输出要求
只输出你负责范围内的问题，不要评审其他维度。
```

#### Agent 输出格式（结构化 JSON）

每个 Agent 必须返回以下结构化输出：

```json
{
  "agent_id": "agent_N",
  "review_group": "评审组名称",
  "dimensions": ["维度1", "维度2"],
  "status": "success | failed | timeout",
  "output": {
    "issues": [
      {
        "dimension": "所属维度",
        "description": "问题描述（业务语言）",
        "impact": "业务影响",
        "suggestion": "修复建议"
      }
    ],
    "score": "高 | 中 | 低",
    "highlights": ["做得好的地方"]
  }
}
```

#### 错误处理规范

| 错误类型 | 处理方式 |
|---------|---------|
| Agent 超时 | 记录超时，继续等待其他 Agent，最终报告中标注 |
| Agent 失败 | 记录失败原因，该评审组标记为"未完成评审" |
| 部分 Agent 失败（≤2个） | 基于成功 Agent 的结果输出报告，明确标注未完成的评审组 |
| 多数 Agent 失败（≥3个） | 报告错误，建议用户重试或手动评审 |

**等待所有 Agent 完成后继续 Phase 4。**

---

### Phase 4: 汇总输出（串行）

> 主 Agent 综合所有评审意见，生成评审报告。

```markdown
## 评审报告

**评审对象**：[/design 输出的架构设计]
**评审时间**：YYYY-MM-DD HH:mm

---

### 总体评价（6 评审组）

| 评审组 | 评分 | 说明 |
|--------|------|------|
| 需求覆盖 | ✅ 高 / ⚠️ 中 / ❌ 低 | [一句话说明] |
| 方案一致性 | ✅ 高 / ⚠️ 中 / ❌ 低 | [一句话说明] |
| 风险安全 | ✅ 低 / ⚠️ 中 / ❌ 高 | [一句话说明] |
| 工程质量 | ✅ 高 / ⚠️ 中 / ❌ 低 | [一句话说明] |
| 性能体验 | ✅ 高 / ⚠️ 中 / ❌ 低 | [仅优化阶段] |
| 设计合理性 | ✅ 简单合适 / ⚠️ 略复杂 / ❌ 过度设计 | [仅开发阶段] |

**当前阶段**：[开发阶段 / 优化阶段]
**总体建议**：✅ 可以继续 / ❌ 必须修复后继续

---

### 🔴 必须修复

> **原则：发现即修复，不留技术债**
>
> 所有评审发现的问题都必须修复。大问题是小问题累积出来的，要做就做到最好。

| # | 问题 | 业务影响 | 修复建议 |
|---|------|---------|---------|
| 1 | [问题描述，用业务语言] | [会导致什么后果] | [具体修复方法] |
| 2 | ... | ... | ... |

---

### 🟢 做得好的地方

> 肯定方案中的优点，建立信心

1. [优点 1]
2. [优点 2]

---

### 下一步

- [ ] 修复全部 X 个问题
- 修复后重新 /critique 确认
- 全部通过后继续执行 [/plan | /run-plan | ...]

或

- ✅ 无问题，可以继续执行 [下一个环节]
```

---

## 业务语言翻译表

**技术问题 → 业务语言**：

| 技术描述 | 业务语言 |
|---------|---------|
| 缺少异常处理，可能导致未捕获的 RuntimeError | 系统出错时会卡住，用户看不到任何提示 |
| N+1 查询问题 | 数据多的时候页面要等很久才能加载出来 |
| 缺少事务控制 | 批量操作可能只成功一半，数据会乱 |
| 没有并发控制 | [看场景] 多人同时操作时可能互相覆盖，数据丢失 |
| 缺少重试机制 | 网络不好时操作会直接失败，用户要重新来 |
| 硬编码配置 | 换环境要改代码，容易出错 |
| 没有缓存 | [优化阶段] 每次操作都很慢，用户体验差 |
| 接口没有限流 | [优化阶段] 被恶意调用时系统会崩溃 |
| 只有一个实现却定义了接口 | [过度设计] 代码过度抽象，增加理解成本 |
| 开发阶段就加了缓存 | [过度设计] 过早优化，增加调试难度，违反项目规范 |
| 为未来需求预设功能 | [过度设计] 代码冗余，增加维护负担 |

**阶段标注说明**：
- `[优化阶段]`：只在性能优化阶段检查，开发阶段不检查（避免过度设计）
- `[看场景]`：根据业务场景判断是否需要（如多人协作场景才需要并发控制）
- `[过度设计]`：违反"简单、合适、演化"原则的设计
- 无标注：所有阶段都检查（基本质量要求）

---

## 不同环节的评审重点

### 评审 /clarify 输出（需求文档）

**重点**：
- 需求是否完整、有无歧义
- 边界情况是否定义清楚
- 验收标准是否可测量

**常见问题**：
- "用户可以管理文档" → 什么操作算管理？增删改查都支持吗？
- "系统要快" → 多快算快？1 秒还是 5 秒？

---

### 评审 /explore 输出（方案选型）

**重点**：
- 方案对比是否全面
- 选择依据是否充分
- 有无遗漏的主流方案

**常见问题**：
- 只对比了 2 个方案，漏了更适合的
- 选择依据是"简单"，但没考虑可扩展性

---

### 评审 /design 输出（架构设计）

**重点**：
- 模块职责是否清晰
- 接口设计是否完整（含错误处理）
- 数据模型是否合理
- 是否违反项目规范

**常见问题**：
- 没有定义接口的错误响应
- 缺少异常情况的处理流程
- 模块间有循环依赖

---

### 评审 /plan 输出（实施计划）

**重点**：
- 步骤顺序是否合理（先后端后前端）
- 每步是否可验证
- 是否遗漏关键步骤
- 是否违反项目铁律
- **AC 是否引用而非重新定义**（新增）
- **测试设计状态是否完整**（新增）

**AC 引用检查项**（阻塞项）：

| 检查项 | 要求 | 常见问题 |
|--------|------|---------|
| AC 来源声明 | 必须声明引用 /clarify 的 AC | 直接定义新的验收场景 |
| AC 文档路径 | 必须指向 `docs/需求文档/clarify_*.md` | 路径错误或缺失 |
| 禁止重新定义 | 不能修改或新增 AC | 在 /plan 中新增了 /clarify 没有的场景 |
| 测试设计状态 | 必须有测试设计检查点 | 缺少门控检查 |

**验收测试场景检查项**（阻塞项）：

| 检查项 | 要求 | 常见问题 |
|--------|------|---------|
| 引用而非定义 | 引用 /clarify 的 AC 表格 | 重新定义 AC |
| 格式正确 | 引用链接 + AC 列表 | 只写了描述，没有引用 |
| 完整性 | 引用所有相关 AC | 遗漏部分 AC |

**常见问题**：
- 先做前端后做后端
- 缺少联调验证步骤
- 步骤粒度太粗，无法验证
- **AC 重新定义而非引用**（阻塞）- /plan 中的 AC 与 /clarify 不一致
- **缺少测试设计状态检查点**（阻塞）- 没有门控确保测试先于开发
- **AC 来源文档路径错误**（阻塞）- 无法追溯到单一来源

---

## 与其他 Skills 的关系

```
/clarify（需求澄清）
    ↓
/explore（方案探索）
    ↓
/design（架构设计）
    ↓ 完成后自动触发
/critique（评审架构）← 自动
    ↓ 评审通过后
/plan（写计划）
    ↓ 完成后自动触发
/critique（评审计划）← 自动
    ↓ 评审通过后
/run-plan（执行计划）
    ↓
/check（检查代码）
    ↓
/qa（测试验收）
```

---

## 禁止行为

| 禁止 | 原因 |
|------|------|
| 敷衍评审，全说"没问题" | 失去评审意义 |
| 用技术术语吓唬用户 | 用户看不懂，无法判断 |
| 只挑刺不给解决方案 | 用户不知道怎么改 |
| 评审时开始改方案 | 评审和修改是两个环节 |

---

## 完成检查清单

- [ ] 识别了评审对象
- [ ] 读取了相关规范
- [ ] 启动了 6 个 Agent 并行评审（6 个评审组，开发阶段启动 5 个）
- [ ] 所有 Agent 返回结果（或已处理超时/失败）
- [ ] 问题用业务语言描述
- [ ] 每个问题都有修复建议
- [ ] 所有问题都列为必须修复（不分级）
- [ ] 给出了明确的下一步建议

---

## ✅ 完成提示

```
✅ 方案评审完成

📊 评审结果：
- 评审阶段：[/clarify | /explore | /design | /plan]
- 发现问题：X 个（全部必须修复）
- 总体评价：[可以继续 / 必须修复后继续]

🎯 下一步：
- [修复全部问题，然后重新 /critique]

评审通过后继续（根据当前阶段）：
- 评审 /clarify 输出 → /explore（方案探索）
- 评审 /explore 输出 → /design（架构设计）
- 评审 /design 输出 → /plan（写计划）
- 评审 /plan 输出 → /test-gen（测试先行）→ /run-plan
```
