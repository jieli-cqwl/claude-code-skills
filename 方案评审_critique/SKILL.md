---
name: critique
command: critique
user_invocable: true
parallel_mode: true
description: 方案评审。在 /design、/plan 完成后可选使用，以守门员视角检查阻塞项（铁律违反、安全漏洞、过度设计）。遵循"简单、合适、演化"原则，不补充需求。
---

# 方案评审 (Critique)

> **角色**：守门员（Gatekeeper）
> **目标**：检查方案是否有阻塞项，确保不违反核心原则
> **原则**：简单、合适、演化；守门而非扩展
> **铁律**：**阻塞项必须修复，建议项可选** — 遵循"简单、合适、演化"原则
> **理论基础**：[CRITIC 框架](https://openreview.net/forum?id=Sx038qxjek)、[Agent-as-a-Judge](https://arxiv.org/html/2508.02994v1)
> **思考模式**：启用 ultrathink 深度思考，聚焦阻塞项检查

---

## 触发条件

当用户使用以下任一方式时，立即激活此 skill：
- 说"**评审方案**"或"**方案评审**"（主触发词）
- 使用命令：`/critique`
- 说"检查一下方案"、"有没有阻塞项"
- 说"方案靠谱吗"、"审查一下"

**适用场景**：
- /design、/plan 完成后（可选，非强制）
- 大型需求（> 10 文件）建议使用
- 涉及安全敏感功能时建议使用

**不适用场景**：
- 小需求（< 3 文件）— 直接开发即可
- 中需求（3-10 文件）— 可选，非必须

---

## 核心理念

**"守门而非扩展"** — 评审的职责是检查阻塞项，不是补充需求。

**解决的问题**：
- 方案是否违反项目铁律
- 方案是否有安全漏洞
- 方案是否过度设计（违反"简单、合适、演化"）

**不做的事情**（这是 /clarify 的职责）：
- ❌ 检查"还缺少什么功能"
- ❌ 补充"万一将来需要"的场景
- ❌ 扩展需求范围

---

## 与 /check 的区别

| 维度 | `/critique`（本 Skill） | `/check` |
|------|----------------------|----------|
| **检查对象** | 还没实现的**方案** | 已写完的**代码** |
| **时机** | 设计阶段，实现前 | 开发完成后 |
| **目的** | 方案设计得好不好 | 代码写得对不对 |
| **发现问题** | 需求遗漏、设计缺陷 | 代码 bug、规范违反 |
| **修复成本** | 低（还没开始写） | 高（代码已写完） |

---

## 依赖规范

> **执行前按需读取**：以下规范文件在评审时按需加载。

| 规范文件 | 覆盖评审项 |
|---------|-----------|
| `~/.claude/rules/RULES.md` | 项目铁律、禁用词汇、文档生命周期 |
| `~/.claude/reference/全栈开发.md` | 前后端同步、API 设计规范 |
| `~/.claude/reference/性能效率.md` | 缓存策略、批量操作、N+1 问题 |
| `~/.claude/reference/代码质量.md` | 函数设计、错误处理、类型注解 |

**执行 /critique 时，根据评审对象自动读取相关规范文件。**

---

## 评审维度（9 维度，分阻塞项和建议项）

### 🔴 阻塞项（必须修复）

| 维度 | 检查内容 | 业务语言示例 |
|------|---------|-------------|
| **铁律违反** | 是否违反项目铁律（禁止降级/硬编码/Mock） | "代码里写死了配置，换环境要改代码" |
| **安全性** | 是否有安全漏洞或隐患 | "用户输入没有校验，可能被注入" |
| **过度设计** | 是否违反"简单、合适、演化"原则 | "只有一个实现却定义了接口，增加理解成本" |
| **AC 一致性** | 方案是否与 AC 一致、内部是否矛盾 | "前面说支持批量，后面只处理单个" |

### 🟡 建议项（可选修复）

| 维度 | 检查内容 | 业务语言示例 |
|------|---------|-------------|
| **可行性** | 技术上能否实现、依赖是否可用 | "这个接口不支持这个参数" |
| **风险** | 可能出什么问题、有什么隐患 | "并发时可能发重复消息给用户" |
| **技术债务** | 是否引入难以维护的设计 | "这个方案后期改起来很麻烦" |
| **可维护性** | 代码是否易于理解和修改 | "这个设计太复杂，后面的人看不懂" |
| **用户体验** | 对用户使用的影响 | "操作步骤太多，用户会觉得繁琐" |

### ❌ 已删除的维度（不再检查）

| 原维度 | 删除原因 |
|--------|---------|
| ~~完整性~~ | 合并到"AC 一致性"，只检查与 AC 是否一致 |
| ~~遗漏分析~~ | **这是 /clarify 的职责**，评审不补充需求 |
| ~~性能影响~~ | 移到 /perf 专门处理，避免过早优化 |

---

## 执行流程

### Phase 0: 识别阶段

> 根据评审对象判断当前处于哪个阶段，决定评审策略

**判断依据**：

| 评审对象 | 判断为 | 评审策略 |
|---------|--------|---------|
| `/clarify` 输出（需求文档） | 需求阶段 | 聚焦需求完整性、一致性 |
| `/explore` 输出（方案选型） | 方案阶段 | 聚焦技术可行性、风险 |
| `/design` 输出（架构设计） | **开发阶段** | 聚焦功能正确性、代码质量、安全性、**过度设计检查** |
| `/plan` 输出（实施计划） | **开发阶段** | 聚焦计划可行性、任务拆分、**过度设计检查** |
| `/perf` 或性能优化需求 | **优化阶段** | 聚焦性能、缓存、并发、限流 |
| 重构需求 | 稳定阶段 | 聚焦可维护性、技术债务 |

**评审维度调整**：

| 阶段 | 评审维度 |
|------|---------|
| **开发阶段** | 完整性、一致性、可行性、遗漏分析、安全性、可维护性、用户体验、**过度设计检查** |
| **优化阶段** | 所有维度 + 性能影响、缓存策略、并发控制、限流策略 |

**输出**：
```markdown
**当前阶段**：[开发阶段 / 优化阶段 / 其他]
**评审策略**：[聚焦哪些维度]
```

---

### Phase 1: 识别评审对象

```markdown
## 评审对象识别

**最近完成的环节**：[/clarify | /explore | /design | /plan]
**输出内容**：[文档名称或内容摘要]
**涉及文件**：[如有，列出相关文件]
```

如果无法识别，询问用户要评审什么。

---

### Phase 2: 读取相关规范

根据评审对象，读取对应的规范文件：

| 评审对象 | 必读规范 |
|---------|---------|
| /clarify 输出 | `~/.claude/rules/RULES.md`（项目铁律） |
| /explore 输出 | `~/.claude/reference/性能效率.md`（性能约束） |
| /design 输出 | `~/.claude/reference/全栈开发.md`、`~/.claude/reference/性能效率.md` |
| /plan 输出 | `~/.claude/reference/全栈开发.md`、`~/.claude/reference/代码质量.md` |

---

### Phase 3: 并行评审（4 Agent）

> **并行策略**：将 9 个评审维度合并为 4 个评审组（2 阻塞项组 + 2 建议项组）。
> 每个 Agent 负责一个评审组，组内维度紧密相关，组间职责互斥。

**执行方式**：使用 Task 工具同时启动 Agent（subagent_type=general-purpose）

#### 4 Agent 评审组分配

| Agent | 评审组 | 包含维度 | 类型 | 独占检查范围 |
|-------|--------|---------|------|-------------|
| Agent 1 | **铁律安全组** | 铁律违反 + 安全性 | 🔴 阻塞项 | 项目铁律、注入攻击、权限漏洞、数据泄露 |
| Agent 2 | **设计合理性组** | 过度设计 + AC 一致性 | 🔴 阻塞项 | 不必要的抽象、过早优化、与 AC 矛盾 |
| Agent 3 | **工程质量组** | 可行性 + 技术债务 + 可维护性 | 🟡 建议项 | 技术可实现性、设计复杂度、模块耦合 |
| Agent 4 | **体验风险组** | 风险 + 用户体验 | 🟡 建议项 | 并发风险、操作流程、错误提示 |

**为什么从 6 组减少到 4 组**：
- 删除了"遗漏分析"维度（不再补充需求）
- 删除了"性能影响"维度（移到 /perf）
- 合并相关维度，提升效率

#### 每个 Agent 的 Prompt 模板

每个 Agent 收到的 Prompt 包含：
1. **方案全文**（必须，评审需要完整上下文）
2. **独占检查范围**（明确该 Agent 只检查什么）
3. **禁止范围**（明确该 Agent 不检查什么，避免越界）

```markdown
你是评审专家，负责「[评审组名称]」评审。

## 你的独占职责
[具体检查项列表]

## 禁止范围（其他 Agent 负责）
[明确列出不属于该 Agent 的检查项]

## 评审对象
[方案全文]

## 输出要求
只输出你负责范围内的问题，不要评审其他维度。
```

#### Agent 输出格式（结构化 JSON）

每个 Agent 必须返回以下结构化输出：

```json
{
  "agent_id": "agent_N",
  "review_group": "评审组名称",
  "dimensions": ["维度1", "维度2"],
  "status": "success | failed | timeout",
  "output": {
    "issues": [
      {
        "dimension": "所属维度",
        "description": "问题描述（业务语言）",
        "impact": "业务影响",
        "suggestion": "修复建议"
      }
    ],
    "score": "高 | 中 | 低",
    "highlights": ["做得好的地方"]
  }
}
```

#### 错误处理规范

| 错误类型 | 处理方式 |
|---------|---------|
| Agent 超时 | 记录超时，继续等待其他 Agent，最终报告中标注 |
| Agent 失败 | 记录失败原因，该评审组标记为"未完成评审" |
| 部分 Agent 失败（≤2个） | 基于成功 Agent 的结果输出报告，明确标注未完成的评审组 |
| 多数 Agent 失败（≥3个） | 报告错误，建议用户重试或手动评审 |

**等待所有 Agent 完成后继续 Phase 4。**

---

### Phase 4: 汇总输出（串行）

> 主 Agent 综合所有评审意见，生成评审报告。

```markdown
## 评审报告

**评审对象**：[/design 输出的架构设计]
**评审时间**：YYYY-MM-DD HH:mm

---

### 总体评价（4 评审组）

| 评审组 | 类型 | 评分 | 说明 |
|--------|------|------|------|
| 铁律安全 | 🔴 阻塞项 | ✅ 通过 / ❌ 阻塞 | [一句话说明] |
| 设计合理性 | 🔴 阻塞项 | ✅ 简单合适 / ❌ 过度设计 | [一句话说明] |
| 工程质量 | 🟡 建议项 | ✅ 高 / ⚠️ 中 / ❌ 低 | [一句话说明] |
| 体验风险 | 🟡 建议项 | ✅ 低 / ⚠️ 中 / ❌ 高 | [一句话说明] |

**总体建议**：✅ 可以继续 / ❌ 有阻塞项，必须修复后继续

---

### 🔴 阻塞项（必须修复）

> 以下问题必须修复后才能继续，否则违反项目核心原则

| # | 问题 | 业务影响 | 修复建议 |
|---|------|---------|---------|
| 1 | [问题描述] | [会导致什么后果] | [具体修复方法] |

---

### 🟡 建议项（可选修复）

> 以下问题建议修复，但不阻塞流程。遵循"简单、合适、演化"原则，可根据实际情况决定

| # | 问题 | 业务影响 | 修复建议 |
|---|------|---------|---------|
| 1 | [问题描述] | [会导致什么后果] | [具体修复方法] |

---

### 🟢 做得好的地方

1. [优点 1]
2. [优点 2]

---

### 下一步

**如果有阻塞项**：
- [ ] 修复全部阻塞项
- 修复后重新 /critique 确认

**如果无阻塞项**：
- ✅ 可以继续执行 [下一个环节]
- 建议项可在后续迭代中处理
```

---

## 业务语言翻译表

**技术问题 → 业务语言**：

| 技术描述 | 业务语言 |
|---------|---------|
| 缺少异常处理，可能导致未捕获的 RuntimeError | 系统出错时会卡住，用户看不到任何提示 |
| N+1 查询问题 | 数据多的时候页面要等很久才能加载出来 |
| 缺少事务控制 | 批量操作可能只成功一半，数据会乱 |
| 没有并发控制 | [看场景] 多人同时操作时可能互相覆盖，数据丢失 |
| 缺少重试机制 | 网络不好时操作会直接失败，用户要重新来 |
| 硬编码配置 | 换环境要改代码，容易出错 |
| 没有缓存 | [优化阶段] 每次操作都很慢，用户体验差 |
| 接口没有限流 | [优化阶段] 被恶意调用时系统会崩溃 |
| 只有一个实现却定义了接口 | [过度设计] 代码过度抽象，增加理解成本 |
| 开发阶段就加了缓存 | [过度设计] 过早优化，增加调试难度，违反项目规范 |
| 为未来需求预设功能 | [过度设计] 代码冗余，增加维护负担 |

**阶段标注说明**：
- `[优化阶段]`：只在性能优化阶段检查，开发阶段不检查（避免过度设计）
- `[看场景]`：根据业务场景判断是否需要（如多人协作场景才需要并发控制）
- `[过度设计]`：违反"简单、合适、演化"原则的设计
- 无标注：所有阶段都检查（基本质量要求）

---

## 不同环节的评审重点

### 评审 /clarify 输出（需求文档）

**重点**：
- 需求是否完整、有无歧义
- 边界情况是否定义清楚
- 验收标准是否可测量

**常见问题**：
- "用户可以管理文档" → 什么操作算管理？增删改查都支持吗？
- "系统要快" → 多快算快？1 秒还是 5 秒？

---

### 评审 /explore 输出（方案选型）

**重点**：
- 方案对比是否全面
- 选择依据是否充分
- 有无遗漏的主流方案

**常见问题**：
- 只对比了 2 个方案，漏了更适合的
- 选择依据是"简单"，但没考虑可扩展性

---

### 评审 /design 输出（架构设计）

**重点**：
- 模块职责是否清晰
- 接口设计是否完整（含错误处理）
- 数据模型是否合理
- 是否违反项目规范

**常见问题**：
- 没有定义接口的错误响应
- 缺少异常情况的处理流程
- 模块间有循环依赖

---

### 评审 /plan 输出（实施计划）

**重点**：
- 步骤顺序是否合理（先后端后前端）
- 每步是否可验证
- 是否遗漏关键步骤
- 是否违反项目铁律
- **AC 是否引用而非重新定义**（新增）
- **测试设计状态是否完整**（新增）

**AC 引用检查项**（阻塞项）：

| 检查项 | 要求 | 常见问题 |
|--------|------|---------|
| AC 来源声明 | 必须声明引用 /clarify 的 AC | 直接定义新的验收场景 |
| AC 文档路径 | 必须指向 `docs/需求澄清/clarify_*.md` | 路径错误或缺失 |
| 禁止重新定义 | 不能修改或新增 AC | 在 /plan 中新增了 /clarify 没有的场景 |
| 测试设计状态 | 必须有测试设计检查点 | 缺少门控检查 |

**验收测试场景检查项**（阻塞项）：

| 检查项 | 要求 | 常见问题 |
|--------|------|---------|
| 引用而非定义 | 引用 /clarify 的 AC 表格 | 重新定义 AC |
| 格式正确 | 引用链接 + AC 列表 | 只写了描述，没有引用 |
| 完整性 | 引用所有相关 AC | 遗漏部分 AC |

**常见问题**：
- 先做前端后做后端
- 缺少联调验证步骤
- 步骤粒度太粗，无法验证
- **AC 重新定义而非引用**（阻塞）- /plan 中的 AC 与 /clarify 不一致
- **缺少测试设计状态检查点**（阻塞）- 没有门控确保测试先于开发
- **AC 来源文档路径错误**（阻塞）- 无法追溯到单一来源

---

## 与其他 Skills 的关系

```
/clarify（需求澄清）
    ↓
/explore（方案探索）← 可选，大需求使用
    ↓
/design（架构设计）← 可选，中/大需求使用
    ↓ 可选
/critique（评审架构）← 可选，大需求或安全敏感时使用
    ↓
/plan（写计划）
    ↓ 可选
/critique（评审计划）← 可选，大需求或安全敏感时使用
    ↓
/run-plan（执行计划）
    ↓
/check（检查代码）
    ↓
/qa（测试验收）
```

**关键变化**：
- `/critique` 从"自动触发"改为"可选使用"
- 小需求（< 3 文件）：跳过 critique
- 中需求（3-10 文件）：可选 critique
- 大需求（> 10 文件）或安全敏感：建议使用 critique

---

## 禁止行为

| 禁止 | 原因 |
|------|------|
| 敷衍评审，全说"没问题" | 失去评审意义 |
| 用技术术语吓唬用户 | 用户看不懂，无法判断 |
| 只挑刺不给解决方案 | 用户不知道怎么改 |
| 评审时开始改方案 | 评审和修改是两个环节 |

---

## 完成检查清单

- [ ] 识别了评审对象
- [ ] 读取了相关规范
- [ ] 启动了 4 个 Agent 并行评审（2 阻塞项组 + 2 建议项组）
- [ ] 所有 Agent 返回结果（或已处理超时/失败）
- [ ] 问题用业务语言描述
- [ ] 每个问题都有修复建议
- [ ] 阻塞项问题列为必须修复
- [ ] 建议项问题列为可选修复
- [ ] 给出了明确的下一步建议

---

## ✅ 完成提示

```
✅ 方案评审完成

📊 评审结果：
- 评审阶段：[/design | /plan]
- 阻塞项：X 个（必须修复）
- 建议项：Y 个（可选修复）
- 总体评价：[可以继续 / 有阻塞项需修复]

🎯 下一步：
- 如有阻塞项：修复后重新 /critique
- 如无阻塞项：继续执行下一环节
- 建议项可在后续迭代中处理（遵循"演化"原则）

评审通过后继续：
- 评审 /design 输出 → /plan（写计划）
- 评审 /plan 输出 → /run-plan（执行计划）
```
